{"meta":{"title":"依夜の妙妙屋","subtitle":"Here is YiyeSss","description":"","author":"依夜","url":"http://yiyecreb.top","root":"/"},"pages":[{"title":"分类","date":"2023-05-24T08:17:10.000Z","updated":"2023-05-24T08:21:53.840Z","comments":true,"path":"categories/index.html","permalink":"http://yiyecreb.top/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2023-05-24T09:04:19.000Z","updated":"2023-06-17T07:40:00.983Z","comments":true,"path":"about/index.html","permalink":"http://yiyecreb.top/about/index.html","excerpt":"","text":"欢迎来到我的博客 My Friends , Welcome to my blog I hope you can have a happy day after reading this 语言 C Java H5,CSS3,JS VUE2 账号 网站 账号 昵称 Gitee YiyeSss 依夜 洛谷 YiyeSss YiyeSss"},{"title":"友情链接","date":"2023-07-26T01:06:54.746Z","updated":"2023-07-26T01:06:54.746Z","comments":true,"path":"friend/index.html","permalink":"http://yiyecreb.top/friend/index.html","excerpt":"","text":"本博客信息 站名： 依夜の小窝 站长： 依夜 地址： https://yiyecreb.top/ 备用地址：https://YiyeSss.github.io/ 申请方法 添加本站后，在本页留言，格式如下 ```yml - name: #您的名字 url: #您的网址 desc: #简短描述 image: #一张图片 ``` 依夜和他的动物朋友们 单天琦 室友，一代大神 金铉杰 室友，一代大神 许帅帅 同学，一代大神 尹寒康 同学，一代大神"},{"title":"标签","date":"2023-05-24T08:19:20.000Z","updated":"2023-05-24T08:22:40.116Z","comments":true,"path":"tags/index.html","permalink":"http://yiyecreb.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis","slug":"Redis","date":"2023-09-20T16:00:00.000Z","updated":"2023-09-21T00:34:26.512Z","comments":true,"path":"2023/09/21/Redis/","link":"","permalink":"http://yiyecreb.top/2023/09/21/Redis/","excerpt":"","text":"Redis简介 概念：Remote dictionary server，是一个开源的基于内存的数据存储系统 功能：可以用作数据库缓存和消息队列等各种场景，是最热门的noSQL数据库之一 优点：随着互联网的发展，应用系统的访问量越来越大，数据库的性能瓶颈越来越明显，主要是由于磁盘IO导致的，磁盘IO的读写速度与内存相比是非常慢的，将数据存储在内存中会大大的提高性能 支持的数据类型： 五种基本数据类型： String：字符串 List：列表 Set：集合 SortedSet：有序集合 Hash：哈希 五种高级数据类型 消息队列：Stream 地理空间：Geospatial HyperLogLog 位图：Bitmap 位域：Bitfield CLI（Command Line Interface）通过Redis-CLI工具使用Redis 应用程序接口 API 图形用户界面 GUI 优势： 性能极高 数据类型丰富，单键值对最大支持512M大小的数据 简单易用，支持所有主流编程语言 支持数据持久化、主从复制、哨兵模式等高可用特性 String 在Redis中数据是以键值对的形式存储的，键和值之间使用空格来分隔，可以使用SET命令设置键值对 &gt; SET NAME YIYE &quot;OK&quot; 使用GET命令获取键值对的值 &gt; GET NAME &quot;YIYE&quot; 注意 Redis中的键是区分大小写的 使用DEL命令删除键值对的值 &gt; DEL NAME (integer) 1&#x2F;&#x2F;返回值为整数类型 使用EXISTS命令查找键值对是否存在 &gt; EXISTS NAME (integer) 0&#x2F;&#x2F;返回值为0表示不存在 使用KEYS命令查看有哪些键 KEYS *&#x2F;&#x2F;表示查找所有的键 KEYS *me&#x2F;&#x2F;表示查找所有以me结尾的键 FLUSHALL(删库跑路、清除所有的键值对) 使用TTL命令查看键值对的过期时间 TTL NAME &gt;-1 &#x2F;&#x2F;表示没有设置过期时间 使用EXPIRE 命令来设置过期时间 EXPIRE NAME 10&#x2F;&#x2F;十秒后过期 &#x2F;&#x2F;再次执行TTL命令会发现时间持续减少，当最后返回值为-2时，说明已经过期了，执行GET、KEYS方法也找不到这个键 也可以使用SETEX命令来设置一个带有过期时间的键值对 SETEX NAME 5 依夜帅的一比 SETNX命令，当键不存在时设置键的值，如果键已经不存在将不会有任何动作 SETNX NAME Y Redis默认是不支持中文的，通过redis-cli --raw启动，即可获取到中文字符 List列表 一般用来操作和存储一些有顺序的数据，和数组的概念比较类似 命令 使用LPUSH命令添加到列表的头部 LPUSH letter a &#x2F;&#x2F;LPUSH也可以添加多个元素，如： LPUSH letter b c d e 使用LRANGE来获取列表中的元素 LRANGE letter 0 -1 &#x2F;&#x2F;表示获取起始位置为0,到最后一个位置的元素(-1为最后一个位置) 1)&quot;a&quot; 使用RPUSH命令添加到列表的尾部 RPUSH letter f 同样的，可以使用LPOP和RPOP来从头部和尾部删除元素 LPOP&#x2F;RPOP letter [COUNT] &#x2F;&#x2F;会返回一个被删除的元素 &#x2F;&#x2F;注：COUNT为被删除的数量，在老版本中是不被支持的 使用LLEN命令来查看列表的长度 LLEN letter &gt;3 使用LTRIM命令删除列表指定以外的元素 LTRIM letter startIndex Set集合 Set中的元素是不能重复的，并没有顺序 命令 SADD命令添加集合 &gt; SADD course Redis (integer) 1 SMEMBERS命令查询集合内容 SMEMBERS course 1)Redis SISMEMBER命令查询元素是否存在 &gt; SISMEMBER course Redis (integer) 1 SREM命令删除集合中的元素 &gt; SREM course Redis (integer) 1 集合的运算 SINTER命令进行交集运算 &gt; SADD course Redis (integer) 1 &gt; SADD course JAVAS (integer) 1 &gt; SADD course1 Redis (integer) 1 &gt; SINTER course course1 1) &quot;Redis&quot; SUNION命令进行并集运算 &gt; SUNION course course1 1) &quot;Redis&quot; 2) &quot;JAVAS&quot; 3) &quot;C#&quot; SDIFF命令进行差集运算 &gt; SDIFF course1 course 1) &quot;C#&quot; &gt; SDIFF course course1 1) &quot;JAVAS&quot; SortedSet有序合集(ZSet) 有序集合与集合的区别是有序集合的每个元素都会关联一个浮点类型的分数，然后按照这个分数来对这个集合中的元素来进行从小到大的排序，有序集合的成员是唯一的，但是分数是可以重复的 命令 ZADD命令向有序集合中添加一个元素 &gt; ZADD result 680 清华 660 北大 650 复旦 640 浙大 (integer) 4 ZRANGE命令查看元素 &gt; ZRANGE result 0 -1 [WITHSCORES 添加后同时输出分数] 1) &quot;浙大&quot; 2) &quot;复旦&quot; 3) &quot;北大&quot; 4) &quot;清华&quot; ZSCORE命令查询分数 &gt; ZSCORE result 清华 &quot;680&quot; ZRANK命令查看某个成员的排名 &gt; ZRANK result 清华 (integer) 3&#x2F;&#x2F;索引为3 ZREVRANK命令查看某个成员的反转排名 &gt; ZREVRANK result 清华 (integer) 0 ZREM命令删除某个成员 &gt; ZREM result 复旦 (integer) 1 哈希Hash 哈希是一个字符类型的字段和值的映射表，简单来说就是一个键值对的集合，特别适合用来储存对象 命令 HSET命令向哈希中添加一个键值对 &gt; HSET person name yiye (integer) 1 &gt; HSET person age 18 (integer) 1 HGET命令获取哈希中键值对的值 &gt; HGET person name &quot;yiye&quot; &gt; HGET person age &quot;18&quot; HGETALL获取整个哈希中的所有键值对 &gt; HGETALL person 1) &quot;name&quot; 2) &quot;yiye&quot; 3) &quot;age&quot; 4) &quot;18&quot; HDEL删除键值对 &gt; HDEL person age (integer) 1 &gt; HGETALL person 1) &quot;name&quot; 2) &quot;yiye&quot; HEXISTS命令来判断某个键值对是否存在 &gt; HEXISTS person name (integer) 1 &gt; HEXISTS person age (integer) 0 HKEYS命令获取哈希中的所有键 &gt; HKEYS person 1) &quot;name&quot; HLENS命令获取哈希中所有键值对的数量 &gt; HLEN person (integer) 1 发布订阅模式 Redis提供了发布订阅模式的功能，通过PUBLISH命令来将消息发送到指定的频道，然后通过SUBSCRIBE命令来订阅这个频道，这样就可以接收到这个频道的消息了 使用： 打开一个终端，使用SUBSCRIBE命令订阅一个频道 在另外一个终端使用PUBLISH命令发送消息 订阅频道的终端可以有多个，但有局限性，例如消息无法持久化，无法记录历史信息等等 消息队列Stream Stream是Redis5.0版本引入的一个新的数据结构，它是一个轻量级的的消息队列，可以用来解决发布订阅功能的一些局限性 命令 XADD，向Stream中添加消息 &gt; XADD yiye * course redis &quot;1694965560109-0&quot; &#x2F;&#x2F;*表示自动生成一个消息的ID XLEB，查看Stream中消息的数量 &gt; XLEN yiye (integer) 3 XRANGE查看Stream中的详细内容 &gt; XRANGE yiye - + 1) 1) &quot;1694965560109-0&quot; 2) 1) &quot;course&quot; 2) &quot;redis&quot; 2) 1) &quot;1694965632269-0&quot; 2) 1) &quot;course&quot; 2) &quot;git&quot; 3) 1) &quot;1694965641518-0&quot; 2) 1) &quot;course&quot; 2) &quot;Ngix&quot; 可以使用XDEL命令来删除消息、 &gt; XDEL yiye 1694965641518-0 (integer) 1 &gt; XRANGE yiye - + 1) 1) &quot;1694965560109-0&quot; 2) 1) &quot;course&quot; 2) &quot;redis&quot; 2) 1) &quot;1694965632269-0&quot; 2) 1) &quot;course&quot; 2) &quot;git&quot; XTRIM命令来删除 &gt; XTRIM yiye MAXLEN 0&#x2F;&#x2F;MAXLEN指所有的消息 (integer) 2 &gt; XRANGE yiye - + (empty list or set) 自己设置ID &gt; XADD yiye 1-0 course git &quot;1-0&quot; &gt; XADD yiye 2-0 course docker &quot;2-0&quot; &gt; XADD yiye 3-0 course redis &quot;3-0&quot; &#x2F;&#x2F;ID的格式是一个整数加上短横线再加上一个整数，第一个整数表示一个时间戳，第二个整数表示一个序列号 XREAD命令来读取消息(消费者需要从消息队列中读取消息，以消费消息（处理消息）) &gt; XREAD COUNT 2 BLOCK 1000 STREAMS yiye 0 1) 1) &quot;yiye&quot; 2) 1) 1) &quot;1-0&quot; 2) 1) &quot;course&quot; 2) &quot;git&quot; 2) 1) &quot;2-0&quot; 2) 1) &quot;course&quot; 2) &quot;docker&quot; &#x2F;&#x2F;COUNT 2表示读取两个消息 &#x2F;&#x2F;BLOCK 1000 表示如果没有就阻塞1000毫秒&#x2F;1秒 &#x2F;&#x2F;STREAMS yiye 0 从STREAM的第一条消息开始读取 &#x2F;&#x2F;可以重复读取 &#x2F;&#x2F;将0改为$则接收最新的消息 XGROUP CREATE 建立消费者组 &gt; XGROUP CREATE yiye group1 0 &quot;OK&quot; &#x2F;&#x2F;yiye指Stream &#x2F;&#x2F;group1为消费者组的名称 &#x2F;&#x2F;0为消费者组的ID XINFO GROUPS来查看消费者组的信息 &gt; XINFO GROUPS yiye 1) 1) &quot;name&quot; 2) &quot;group1&quot; 3) &quot;consumers&quot; 4) &quot;0&quot; 5) &quot;pending&quot; 6) &quot;0&quot; 7) &quot;last-delivered-id&quot; 8) &quot;0-0&quot; XGROUP CREATECONSUMER 添加消费者 XGROUP CREATECONSUMER yiye group1 consumer1 XGROUP CREATECONSUMER yiye group1 consumer2 XGROUP CREATECONSUMER yiye group1 consumer3 XREADGROUP GROUP读取消费者组的消息 XREADGROUP GROUP group1 consumer1 COUNT 2 BLOCK 1000 STREAMS yiye &gt;&#x2F;&#x2F;读取最新消息","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yiyecreb.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Git","slug":"Git","date":"2023-09-19T16:00:00.000Z","updated":"2023-09-20T05:46:44.671Z","comments":true,"path":"2023/09/20/Git/","link":"","permalink":"http://yiyecreb.top/2023/09/20/Git/","excerpt":"","text":"Git概述 Git是一个分布式版本控制系统，用于追踪文件和目录的变更 源代码管理工具 CVS SVN VSS Git 主要功能 记录历史信息 团队协作 三个区域 版本库：已提交到Git仓库中的数据 暂存区：下一次要提交的文件的快照 工作目录：编写代码的目录 使用 初始化仓库 //在项目文件夹中 git init //如果项目文件夹不存在，创建文件夹并初始化 git init 文件夹名 配置 git config --global user.name \"XXXXX\" git config --global user.email \"xxx@xx.xxx\" 添加文件到缓存区中 git add 文件名 //添加所有上次提交后改变的文件 git add . 查看git状态 //显示暂存区与工作区状态不同的文件，其中包含了已修改但未暂存或已经暂存但没有提交的文件 git status 提交 git commit -m \"提交说明\" //会打开一个文件，在其中添加注释，适合于注释内容比较多和需要换行的情况 git commit 查看命令帮助 git --help 命令名 如 git --help commit 查看提交历史 git log //n:显示的提交数 git log -n 撤销 舍弃工作目录中对一个文件的修改(修改的文件未被暂存或提交) //这是一个危险动作 git checkout 文件名 舍弃工作目录中所有未保存的变更(文件可能已经暂存，也可能没有，但未被提交) //这是一个危险动作 git reset --hard 从工作目录中删除未跟踪(新添加的未缓存或提交过)的文件 //-f:强制删除 //-d:删除未跟踪的文件 git clean -fd 修补最后一次提交 //只修改最后一次提交的注释 git commit -m \"最新注释\" --amend //新添加了内容,先把新内容添加到暂存区 git add . //提交 git commit -m \"新注释\" --amend 恢复到某次提交 git reset --hard 提交ID 显示所有提交历史 git reflog 重要的目录结构 objects 目录存储所有数据内容 refs 目录存储结构指向数据(分支)的提交对象的指针 HEAD 文件 指示目前检出的分支 index文件保存暂存区信息 远程连接 注册Gitee账号 登录Gitee 创建一个仓库 配置远程 git remote add 远程名称 地址 例如： git remote add origin https://gitee.com/YiyeSss/second_hand.git 拉取 //拉取远程(允许不相同的历史) git pull origin master --allow-unrelated-histories 推送 git push 远程名称 分支名 例如： git push origin master 克隆 git clone 远程仓库地址 文件夹名","categories":[{"name":"Git","slug":"Git","permalink":"http://yiyecreb.top/categories/Git/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"JavaWeb","slug":"JavaWeb","date":"2023-09-07T16:00:00.000Z","updated":"2023-09-14T01:06:24.030Z","comments":true,"path":"2023/09/08/JavaWeb/","link":"","permalink":"http://yiyecreb.top/2023/09/08/JavaWeb/","excerpt":"","text":"JavaWeb前期内容 Java基础(Java语法，面向对象概念，集合) MySql、Oracle JDBC(SpringJDBCTemplate)、数据库连接池 HTML、CSS，JavaScript，Vue.js 后期内容 JavaWeb、AJAX(axios) 框架(SSM) SpringMVC Spring Mabits SpringBoot JavaWeb相关概念软件架构 C&#x2F;S：client&#x2F;Server，客户端&#x2F;服务器 客户端需要安装专用的客户端软件 客户端要负责绝大多数的业务逻辑和UI的展示，又称为胖客户端，它充分利用两端硬件，将任务分配到client和Server端，降低了系统的通讯开销 缺点:增加了系统维护和升级的支出成本 B&#x2F;S：Browser&#x2F;Server，浏览器&#x2F;服务器 只要有浏览器就可以，不需要单独安装 主要事务逻辑在服务器端实现，这样使得客户端电脑负荷大大简化，称为瘦客户端 好处：减轻了系统维护和升级的支出成本 WebWeb是全球广域网，也称为万维网(www.)，能够通过浏览器访问网站 Web开发的三要素 URL：统一资源定位服务 HTTP：超文本传输协议，主要定义了请求和响应的数据格式 HTML：超文本标记语言，用来编写网页，由浏览器解释并展示 URL统一资源定位符，用来完整地描述Internet上网页和其他资源的地址的一种表示方法 组成：协议+服务器地址(端口号)+具体的资源路径 如：http://192.168.6.156:8080/index.html IP：在网络上标识唯一主机 端口号：应用程序在计算机中的唯一软件标识，0——65536 传输协议：规定了数据传输的规则，如：http、ftp等 资源分类 静态资源：所有用户访问后得到的结果都是一样的，静态资源可以直接被浏览器解释 如：html、css、JavaScript、图片 动态资源：每个用户访问相同资源后，得到的结果可能不一样，需要先转换为静态资源，再返回给浏览器 如：Servlet、JSP、php、sap.net JavaWeb就是使用java语言开发动态web应用程序的技术 Web服务器软件用途：接受用户的请求，处理请求，并给出响应 常用的Web服务器软件 Tomcat：是一种小型轻量级的支持JSP和Servlet技术的Web服务器 IIS：Windows服务器自带的一种web服务器，支持：asp、asp、net Apache：世界排名第一，免费开源的web服务器(只支持静态资源访问) Nginx：是一种高性能的web和反向代理服务器 商业化 websphere：IBM公司 webLogic：Oracle公司 HTTP超文本传输协议，规定了浏览器和服务器之间数据传输规则 HTTP协议的特点 基于TCP协议：面向连接、安全 TCP是一种面向连接(建立的时候连接之前是需要经过三次握手)、可靠的，基于字节流的传输层工具通信协议，在传输数据上是更安全的 UDP：非面向连接、不是特别安全可靠 基于请求-响应模式：一次请求对应一次响应 HTTP协议是无状态的协议：对于事务处理没有记忆能力，每次请求-响应都是独立的 通过Cookie，Session技术，保证会话完整，在一个会话过程中共享数据 格式介绍http请求分为三部分 请求行 请求方式：GET、POST 请求的URL路径 协议和版本号 请求头：第二行开始，格式：key:value形式 Host：表示请求的主机名 User-Agent：浏览器的版本 Accept：表示浏览器能接收到的资源类型，如：text&#x2F;html,image&#x2F;png 请求体 post请求的最后一部分，存储请求的参数(格式：键值对形式) ?username&#x3D;tom&amp;password&#x3D;111 http响应数据格式分为三部分 响应行：响应数据的第一行，三部分组成，协议名和版本号，响应状态码，状态码的描述 响应头：第二行开始，格式：key:value形式 content-type：表示响应内容的类型，如：text&#x2F;html，image&#x2F;jpg content-length：表示响应内容的长度(字节数) 响应体：最后一部分，存放响应的内容 响应状态码200：ok，客户端请求成功 404：Not found，请求的资源不存在 500：Internal Server Error，服务器端发生不可预期的错误(服务器异常) Tomcat概述 免费，开源的JavaWeb服务器 是一种JSP和Servlet容器 是Apache软件基金会的一个核心项目 Web服务器软件是一个应用软件，对HTTP协议的操作进行了封装，使得程序员不必直接对协议进行操作，开发更方便 使用 下载：Apache Tomcat® - Welcome! 安装：解压(先安装和配置jdk) 卸载：删除目录即可 启动服务器： bin&#x2F;startup.bat双击运行 访问自己：http://localhost:8080 访问别人：http:&#x2F;&#x2F;别人的ip地址:8080 可能遇到的问题 黑窗口一闪而过 主要原因：JDK的配置问题 端口被占用 关闭 正常关闭 bin&#x2F;shutdown.bat 强制关闭 关闭窗口 Ctrl+C Tomcat目录结构 bin：Tomcat运行的核心文件 conf：配置文件 lib：存放服务器启动需要的jar包 logs：日志 temp：临时文件 webapps：存放所有web应用程序的地方，这里的每一个文件夹就是一个web应用程序 work：存放由JSP生成的Servlet代码的地方 JavaWeb应用程序的目录结构 &#x2F;app_name：web应用的根目录，web应用的所有文件和文件夹都放在这个下面 &#x2F;app_name&#x2F;WEB-INF： 存放web应用的部署描述文件(web.xml) 该目录受到保护，里面的文件不能被用户直接访问到 &#x2F;app_name&#x2F;WEB-INF&#x2F;classes：java字节码文件 &#x2F;app_name&#x2F;WEB-INF&#x2F;lib：存放依赖包(jdbc驱动) &#x2F;app_name&#x2F;META-INF：存放配置应用程序，扩展程序的文件(数据库连接池) ServletServer Applet，运行在服务器的小程序 作用 读取客户信息(接受请求) 数据处理 发送响应给客户端浏览器 创建 导入Servlet依赖包 定义一个类，继承HttpServlet类 package com.neu.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(value = \"/hello\") public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //得到响应对象中的输出流对象 resp.getWriter().println(\"Hello World!\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req,resp); &#125; &#125; Servlet生命周期 生命周期：指的是一个对象被创建到被销毁的整个过程（默认情况下，Servlet是单例的） 分为4个阶段 加载和实例化：默认情况下，当Servlet第一次被访问的时候，由容器创建Servlet对象 @WebServlet(value &#x3D; “&#x2F;LoginServlet”,loadOnStartup &#x3D; 1)，其中loadOnStartup 的值为0或正数，表示容器启动的时候创建，默认值为-1 初始化：调用init()方法，该方法只执行一次 请求处理：调用service()方法每处理一个请求，调用一次 在HttpServlet中，重写Service()方法，根据请求的method值，来调用doGet或doPost等方法 服务终止：调用destroy()方法，在容器关闭的时候会释放这个Servlet实例，会调用这个方法 Servlet的体系结构Servlet 接口 | GenericServlet 抽象类，重写了除service()方法之外的其他方法 | HttpServlet 重写了 service()、doGet()、doPost()等方法 | 自定义的Servlet 重写 doGet()、doPost() urlPattern配置 一个Servlet，可以配置多个urlPattern @WebServlet(urlPatterns &#x3D; &#123;&quot;&#x2F;LoginServlet&quot;,&quot;&#x2F;login&quot;&#125;) urlPattern配置规则 精确匹配 @WebServlet(urlPatterns &#x3D; &#123;&quot;&#x2F;LoginServlet&quot;,&quot;&#x2F;login&quot;&#125;) 目录匹配 @WebServlet(urlPatterns &#x3D; &#123;&quot;&#x2F;admin&#x2F;*&quot;&#125;) http:&#x2F;&#x2F;localhost:8090&#x2F;javawebdemo3&#x2F;admin&#x2F;a&#x2F;b 精确匹配的优先级高于目录匹配 扩展名匹配 @WebServlet(urlPatterns &#x3D; &#123;&quot;*.do&quot;&#125;) http:&#x2F;&#x2F;localhost:8090&#x2F;javawebdemo3&#x2F;a.do 常见错误：/*.do, /a/*.do 任意匹配 @WebServlet(urlPatterns &#x3D; &#123;&quot;&#x2F;*&quot;&#125;) http:&#x2F;&#x2F;localhost:8090&#x2F;javawebdemo3&#x2F;a.action HttpServletRequest 定义：请求对象，封装了用户通过浏览器提交的所有数据 得到请求数据 getMethod():获取请求方式 getContextPath():获取项目部署时候的名称（应用程序上下文名） getRequestURL():获取请求地址 getRequestURI()获取请求资源名称 URI：统一资源标识符 URL：统一资源定位符，是在互联网上，通过网址定位资源的一种方式，是URI的子集 getHeader(String name):根据请求头名称获取其值 String host &#x3D; req.getHeader(&quot;Host&quot;); getReader():得到请求体（字符类型），注意：只有post请求有请求体 BufferedReader reader &#x3D; req.getReader(); String s &#x3D; reader.readLine(); getInputStream():得到请求体（返回字节流，字节数据，如：文件） ServletInputStream inputStream &#x3D; req.getInputStream(); BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(inputStream)); String s &#x3D; reader.readLine(); 得到请求参数：通过表单提交的数据，或者附加在get请求的地址后的数据 ?username&#x3D;tom&amp;password&#x3D;123 getParameter(String name) getParameterValues(String name):根据请求参数名得到一组值（字符串数组） http:&#x2F;&#x2F;localhost:8090&#x2F;javawebdemo666&#x2F;LoginServlet?hobby&#x3D;java&amp;hobby&#x3D;game String[] hobbies &#x3D; req.getParameterValues(&quot;hobby&quot;); System.out.println(Arrays.toString(hobbies)); Map&lt;String,String[]&gt; getParameterMap():得到所有的请求参数 Map&lt;String, String[]&gt; parameterMap &#x3D; req.getParameterMap(); for(String key : parameterMap.keySet())&#123; System.out.println(key+&quot;:&quot;+Arrays.toString(parameterMap.get(key))); &#125; 中文乱码问题 get方法：tomcat9以上版本，已经解决 post方法 &#x2F;&#x2F;在第一次得到请求参数之前调用 req.setCharacterEncoding(&quot;utf-8&quot;); req.getParameter(&quot;username&quot;); 请求转发 一种在服务器内部的资源跳转方式 ~~~ - 注意： - 地址栏显示的是请求资源的地址 - 只能访问当前应用的其他资源，不能访问外部资源 - 一次请求一次响应 5. 传递数据 - request.setAttribute(String key,Object object)：放置键值对 - Object request.getAtrribute(String key)：根据key得到值 - request.removeAttribute(String key)：根据key移除键值对 #### HttpRequestResponse 1. 响应对象，封装了响应相关的操作 2. 常用方法 - 响应行 - setStatus(int code):设置响应编码 - 响应头 - setHeader(String key,String value) ~~~java &#x2F;&#x2F; resp.setHeader(&quot;Content-Type&quot;,&quot;text&#x2F;html;charset&#x3D;utf-8&quot;); resp.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;); 响应体 得到字符输出流：PrintWrite getWriter() resp.getWriter().println(\"&lt;html>\"); resp.getWriter().println(\"&lt;body>\"); resp.getWriter().println(\"&lt;h1>Other Servlet&lt;/h1>\"); resp.getWriter().println(\"&lt;/body>\"); resp.getWriter().println(\"&lt;/html>\"); 得到字节输出流： ServletOutputStream getOutputStream() 重定向 是一种资源跳转的方式 resp.sendRedirect(&quot;&#x2F;javaWebDemo2&#x2F;OtherServlet&quot;); 注意： 地址栏中显示的是最终响应资源的地址 二次请求，二次响应 在一个Servlet中处理多个请求package com.neu.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(value = \"/UserServlet\") public class UserServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //UserServlet?action=login req.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); String action = req.getParameter(\"action\"); if (\"login\".equals(action))&#123; doLogin(req,resp); &#125; else if (\"regist\".equals(action)) &#123; doRegist(req,resp); &#125; &#125; private void doRegist(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123; resp.getWriter().println(\"注册成功\"); &#125; private void doLogin(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123; resp.getWriter().println(\"登录成功\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125; &#125; Get和Post的区别 get和post是两种不同的http的请求方法，用于在客户端和服务器之间传递数据，但是在使用和用途上有一些明显的区别 Get请求： 用途：用于从服务器获取数据，通常用于读取数据(查询) 数据传输：通过URL参数传递的数据，数据附加在URL的末尾 数据长度限制：有限制，因为URL的长度受限制，通常是2048个字符 安全性：较不安全，因为数据在URL中可见，容易被拦截，不适用于敏感数据 缓存：可以被缓存，浏览器可以缓存get请求，以提高性能 Post请求 用途：用于向服务器提交数据，通常用于写入操作，如添加，修改，删除 数据传输：通过HTTP请求体传递数据，数据在URL中不可见 数据长度限制：较大，通常没有固定的长度限制，但是服务器和浏览器可能有各自的配置限制 安全性：相对较安全，因为数据在URL中不可见，更适合传递敏感数据 缓存：通常不缓存，因为post请求通常会对服务器状态进行更改，而不适合被缓存 RESTFull编程风格Http动词 GET:用于获取资源的信息(查询) POST:用于创建新资源(添加) PUT:用于更新资源(修改) DELETE:用于删除资源 前端向后端传输数据 传输查询字符串 POST http://localhost:8080/newsdemo/SecondTitleServlet Content-Type: application/x-www-form-urlencoded titleName=news999&amp;creator=tom&amp;newContent=jxl&amp;parentTitleId=2 - 后端 ~~~java String titleName &#x3D; request.getParameter(&quot;titleName&quot;); http客户端中测试 GET http://localhost:8080/newsdemo/SecondTitleServlet?action=getAll ### GET http://localhost:8080/newsdemo/SecondTitleServlet?action=Search&amp;sid=1 ### GET http://localhost:8080/newsdemo/SecondTitleServlet?action=getByPaged&amp;pageNum=2&amp;pageSize=3 ### POST http://localhost:8080/newsdemo/SecondTitleServlet Content-Type: application/x-www-form-urlencoded titleName=news999&amp;creator=tom&amp;newContent=jxl&amp;parentTitleId=2 ### DELETE http://localhost:8080/newsdemo/SecondTitleServlet?sid=6 ### PUT http://localhost:8080/newsdemo/SecondTitleServlet?sid=6&amp;titleName=news1145&amp;creator=tom&amp;newContent=jxl&amp;parentTitleId=2 ### 传输JSON数据格式 &#123; &quot;titleName&quot;:&quot;news666&quot;, &quot;creator&quot;:&quot;tom&quot;, &quot;newContent&quot;:&quot;888&quot;, &quot;parentTitleId&quot;:1, &quot;sid&quot;:1 &#125; - ~~~java &#x2F;&#x2F;得到JSON数据字符串 BufferedReader reader &#x3D; req.getReader(); StringBuilder stb &#x3D; new StringBuilder(); String line; while ((line &#x3D; reader.readLine()) !&#x3D; null)&#123; stb.append(line); &#125; &#x2F;&#x2F;解析JSON字符串为对象，可以使用Gson.jar来解析 Gson gson &#x3D; new Gson(); SecondTitle secondTitle &#x3D; gson.fromJson(stb.toString(), SecondTitle.class); System.out.println(secondTitle); ServletUtilspackage com.neu.news.utils; import com.google.gson.Gson; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.IOException; public class ServletUtils &#123; private static Gson gson = new Gson(); public static &lt;T> T parseJSONRequest(HttpServletRequest request,Class&lt;T> clazz) throws IOException &#123; StringBuffer jsonBuilder = new StringBuffer(); try(BufferedReader reader = request.getReader()) &#123; String line; while ((line = reader.readLine()) != null)&#123; jsonBuilder.append(line); &#125; &#125; String jsonData = jsonBuilder.toString(); return gson.fromJson(jsonData,clazz); &#125; public static void sendJsonResponse(HttpServletResponse response,Object obj) throws IOException &#123; response.setContentType(\"application/json;charset=utf-8\"); response.getWriter().println(gson.toJson(obj)); response.getWriter().flush(); &#125; &#125; //查询 private void doGetByPaged(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123; int pageNum = Integer.parseInt(req.getParameter(\"pageNum\")); int pageSize = Integer.parseInt(req.getParameter(\"pageSize\")); List&lt;SecondTitle> list = secondTitleDao.getByPaged(pageNum, pageSize); ServletUtils.sendJsonResponse(resp,list); &#125; private void doGetAll(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123; List&lt;SecondTitle> all = secondTitleDao.getAll(); ServletUtils.sendJsonResponse(resp,all); &#125; private void doSeacher(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123; int sid = Integer.parseInt(req.getParameter(\"sid\")); SecondTitle byId = secondTitleDao.getById(sid); ServletUtils.sendJsonResponse(resp,byId); &#125; //得到java对象从JSON对象 SecondTitle secondTitle = ServletUtils.parseJSONRequest(req, SecondTitle.class); Cookie 定义：是一小段的文本信息，web服务器将它发送到浏览器，之后浏览器在访问同一网站的时候又将它原封不动地返回给服务器 创建 Cookie cookie = new Cookie(string name,string value);//value中不能有空格 发送给浏览器 response.addCookie(cookie); 得到Cookie Cookie[] cookies = req.getCookies(); String lastTime = null; for(Cookie cookie : Cookies)&#123; if(cookie.getName().equals(\"lastTime\"))&#123; lastTime = cookie.getValue(); break; &#125; &#125; getName():得到当前cookie的名字 getValue():得到当前cookie的值 持久化Cookie void setMaxAge(int)：设置cookie的最大生存期，以秒为单位 参数值为正数，表示cookie将在经过该值表示的秒数后到期 负值意味着cookie不会被持久化，将在内存中，将在浏览器退出的时候就删除 0表示让浏览器删除cookie 缺点： 保存在客户端，相对不安全，保存数据的时候最好加密 增加了请求的数据量 客户端可以禁用Cookie Session HttpSession：会话对象，保存会话期间当前用户的信息，其他用户不能访问 得到Session对象 HttpSession session = request.getSession(); 向Session中添加数据 session.setAttribute(string key,Object obj); 得到Session中的数据 Object obj = session.getAttribute(string key); 注销Session session.invalidate(); 设置最大间隔时间 session.setMaxInactiveInterval(60*30);//单位为秒 注意：session信息放到服务器中，不到万不得已，不要用 原理： 当第一次访问服务器并调用了getSession()方法，服务器会创建一个SessionID和一个Session对象，并将他们关联起来，然后把SessionID放到cookie里，cookie随着响应发送给用户浏览器 用户在会话结束前，再次访问服务器的时候，浏览器会把上次送来的包含SessionID的Cookie，发送回服务器 服务器根据SessionID找到之前关联的用户的HttpSession对象 Filter 定义：对Servlet容器的请求和响应对象进行检查和修改 过滤的内容：Servlet，JSP，html，图片，css等 使用 定义一个类，实现Filter接口，重写抽象方法 init()：初始化方法，只执行一次 doFilter()：过滤的方法，每拦截一次请求，该方法执行一次 destroy()：销毁的时候执行的方法，只执行一次 FilterChain：过滤器链，用来调用下一个组件(Filter、Servlet) 在一个web应用中都可以部署多个过滤器，这些过滤器组成了一个过滤器链 编码过滤器 package com.neu.servlet; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.annotation.WebInitParam; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebFilter(value = \"/*\",initParams = &#123;@WebInitParam(name=\"encoding\",value = \"utf-8\")&#125;) public class EncodingFilter implements Filter &#123; private String encoding; /** * @param servletRequest * @param servletResponse * @param filterChain * @throws IOException * @throws ServletException */ @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; servletRequest.setCharacterEncoding(\"utf-8\"); // servletResponse.setContentType(\"application/json;charset=utf-8\"); ((HttpServletResponse)servletResponse).setCharacterEncoding(\"utf-8\"); //放行，调用下一个组件(另一个filter，Servlet) filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; filterConfig.getInitParameter(\"encoding\"); &#125; &#125; 登录检查Filterpackage com.neu.servlet; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; @WebFilter(value=\"/*\") public class CheckLoginFilter implements Filter &#123; /** * @param servletRequest * @param servletResponse * @param filterChain * @throws IOException * @throws ServletException */ @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request = ((HttpServletRequest) servletRequest); HttpServletResponse response = ((HttpServletResponse) servletResponse); String uri = request.getRequestURI(); if (!(uri.endsWith(\"login.html\")||uri.endsWith(\"LoginServlet\")))&#123; HttpSession session = request.getSession(); Object username = session.getAttribute(\"username\"); if (username == null)&#123; response.sendRedirect(request.getContextPath()+\"/login.html\"); &#125; &#125; filterChain.doFilter(servletRequest,servletResponse); &#125; &#125; AJAX 定义：Asynchronous 异步的 JavaScriptjav And和XML 异步的：它允许在发送请求后继续执行其他任务，不必等待服务器响应，当服务器返回响应后，会触发回调函数来处理请求，好处：提高用户体验 同步的：同步请求是阻塞的，浏览器在发送请求后会一直等待服务器响应直到响应返回或超时为止，缺点：用户体验差 Axios 定义：对原生的Ajax进行了封装，简化书写 安装 npm install axios 跨域问题(Cross Origin Resource Share，CORS)，是一个常见的安全问题，它涉及到在一个网页中加载来自不同域名(或协议、端口号)的资源时的安全限制，这是浏览器实施的一种安全的策略 package com.neu.news.filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebFilter(value = \"/*\") public class CORSFilter implements Filter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletResponse httpResponse = (HttpServletResponse) servletResponse; // 允许的跨域来源，这里设置为允许所有来源，你可以根据需要进行配置 httpResponse.setHeader(\"Access-Control-Allow-Origin\", \"*\"); // 允许的 HTTP 方法，例如 GET、POST、PUT、DELETE 等 httpResponse.setHeader(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\"); // 允许的自定义请求头字段，可以根据你的需求添加 httpResponse.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\"); // 允许发送凭据（例如，带有 cookie 的请求） httpResponse.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); // 预检请求的有效期，单位为秒 httpResponse.setHeader(\"Access-Control-Max-Age\", \"3600\"); // 继续执行过滤链 filterChain.doFilter(servletRequest, servletResponse); &#125; &#125; 发送Get请求 路径参数 const url &#x3D; &#96;http:&#x2F;&#x2F;localhost:8080&#x2F;newsdemo&#x2F;UserServlet?action&#x3D;login&amp;username&#x3D;$&#123;username.value&#125;&amp;password&#x3D;$&#123;password.value&#125;&#96;; axios.get(url).then(resp &#x3D;&gt;&#123; if (resp.data.status &#x3D;&#x3D; 200)&#123; alert(&quot;用户&quot;+resp.data.data.username+&quot;登录成功&quot;) &#125;else &#123; alert(resp.data.msg) &#125; &#125;) url参数 const url &#x3D; &#96;http:&#x2F;&#x2F;localhost:8080&#x2F;newsdemo&#x2F;UserServlet?action&#x3D;login&#96;; axios.get(url,&#123; params:&#123; username:username.value, password:password.value &#125; &#125;).then(resp &#x3D;&gt;&#123; if (resp.data.status &#x3D;&#x3D; 200)&#123; alert(&quot;用户&quot;+resp.data.data.username+&quot;登录成功&quot;) &#125;else &#123; alert(resp.data.msg) &#125; &#125;) 发送POST请求 通过data选项发送数据(json) import &#123;reactive&#125; from &quot;vue&quot;; import axios from &quot;axios&quot;; const firstTitle &#x3D; reactive(&#123; titleName:&quot;&quot;, creator:&quot;&quot; &#125;) const addFirst &#x3D; ()&#x3D;&gt;&#123; const url &#x3D; &quot;http:&#x2F;&#x2F;localhost:8080&#x2F;newsdemo&#x2F;FirstTitleServlet&quot; axios.post(url,firstTitle).then(resp&#x3D;&gt;&#123; if (resp.data.status &#x3D;&#x3D; 200 &amp;&amp; resp.data.data &#x3D;&#x3D; 1)&#123; alert(resp.data.msg) &#125;else &#123; alert(&quot;添加失败&quot;) &#125; &#125;) &#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yiyecreb.top/categories/JavaWeb/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"VUE","slug":"Vue","date":"2023-08-30T16:00:00.000Z","updated":"2023-09-21T00:40:36.478Z","comments":true,"path":"2023/08/31/Vue/","link":"","permalink":"http://yiyecreb.top/2023/08/31/Vue/","excerpt":"","text":"Vue概述 Vue.js是一个专注于构建Web用户界面的JavaScript库 作者：尤雨溪，中国人，早前就职于Google公司 思想：MVVM(Model-View-ViewModel) M:Model，模型(数据和业务逻辑) View:视图 ViewModel：视图模型，是一个纽带，它连接模型和视图 一个渐进式的框架 使用 安装 //使用CDN &lt;script src=\"https://unpkg.com/vue@3/dist/vue.global.js\">&lt;/script> //先安装node.js，在当前终端中：npm install vue &lt;script src=\"./node_modules/vue/dist/vue.global.js\">&lt;/script> 创建第一个案例 &lt;div id=\"app\"> &#123;&#123;msg&#125;&#125; &lt;/div> &#x2F;&#x2F;app表示一个Vue的应用实例 const app &#x3D; Vue.createApp(&#123; data()&#123; return&#123; msg:&#39;Hello!!&#39; &#125; &#125; &#125;); &#x2F;&#x2F;root表示Vue应用的根组件 const root &#x3D; app.mount(&quot;#app&quot;); Vue:是一个包含各种工具和方法的对象，用来创建并配置一个新的Vue应用实例 Vue.createApp(Vue组件配置对象)：创建了一个新的Vue应用实例 mount(“#app”)：把Vue实例挂载到id为app的div上 root：表示一个根组件实例，可以通过这个实例来访问组件的属性，方法和数据 组件的data()方法返回的对象中的数据属性可以直接在组件的模板中访问，也可以通过组件的实例来访问。但注意。data()方法必须返回一个对象 ():插值表达式，指的是使用双大括号&#123;&#123;&#125;&#125;在模板中嵌入动态的值 语法插值表达式 在插值表达式中可以写简单的js表达式 不是语句，不能写控制语句 指令Vue提供了一系列的内置指令，用于在模板中执行一些常见的任务，如条件渲染，列表渲染，事件监听等，这些指定都是以v-前缀开头的 v-text：用于更新元素的textContent，不会对数据中的html进行解析 v-html：用于更新元素的innerHTML，会对数据中的html标签进行解析，显示解析后的结果 v-bind：用于绑定属性到表达式，简写形式：: v-model：绑定表单数据，双向绑定 &lt;input v-model=\"title\"> data()&#123; return&#123; title:'tom' &#125; &#125; v-on：绑定事件处理程序，简写:@ &lt;div id=\"app\"> &lt;input v-on:click=\"test\" type=\"button\" value=\"测试\"> &lt;input :value=\"abc\"> &lt;/div> &lt;script> const root = Vue.createApp(&#123; data() &#123; return &#123; abc:'', &#125; &#125;, methods:&#123; test()&#123; this.abc=\"tom\"//this:当前vue组件 &#125; &#125; &#125;).mount(\"#app\"); &lt;/script> v-show：是否显示元素，元素的显示和隐藏是通过css的display属性来控制的 &lt;p v-show=\"b\">abc&lt;/p> &lt;script> const root = Vue.createApp(&#123; data() &#123; return &#123; b:false &#125; &#125;,methods:&#123; ifshow()&#123; this.b=!this.b &#125; &#125; &#125;).mount(\"#app\"); &lt;/script> v-if,v-else-if,v-else：用于条件渲染 &lt;div id=\"app\"> &lt;input v-model=\"score\"> &lt;p v-if=\"score>=90\">优秀&lt;/p> &lt;p v-else-if=\"score>=80\">良好&lt;/p> &lt;p v-else-if=\"score>=70\">中等&lt;/p> &lt;p v-else-if=\"score>=60\">及格&lt;/p> &lt;p v-else>不及格&lt;/p> &lt;/div> &lt;script> const root = Vue.createApp(&#123; data() &#123; return &#123; score:90 &#125; &#125; &#125;).mount(\"#app\"); &lt;/script> v-if和v-show的区别 v-if:如果为false，会删除DOM元素，为true，会创建DOM元素 v-show：通过样式显示和隐藏元素，隐藏时并不会删除DOM元素 v-for：用于渲染列表 &lt;table border=\"1\"> &lt;tr> &lt;th>学号&lt;/th> &lt;th>姓名&lt;/th> &lt;th>年龄&lt;/th> &lt;/tr> &lt;tr v-for=\"(stu,index) in stus\":key=\"stu.index\"> &lt;td>&#123;&#123;index+1&#125;&#125;&lt;/td> &lt;td>&#123;&#123;stu.name&#125;&#125;&lt;/td> &lt;td>&#123;&#123;stu.age&#125;&#125;岁&lt;/td> &lt;/tr> &lt;/table> &lt;/div> &lt;script> const root = Vue.createApp(&#123; data() &#123; return &#123; stus:[ &#123;name:'tom',age:20&#125;, &#123;name:'marry',age:18&#125;, &#123;name:'scott',age:25&#125; ] &#125; &#125; &#125;).mount(\"#app\"); &lt;/script> vue使用”就地复用”的思想复用已经生成的DOM,使用绑定key属性来确定DOM属性是否已经创建，要求key的值是唯一的 表单样例 &lt;!DOCTYPE html> &lt;html lang=\"zh-CN\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;script src=\"./node_modules/vue/dist/vue.global.js\">&lt;/script> &lt;/head> &lt;body> &lt;div id=\"app\"> &lt;table border=\"1\"> &lt;tr> &lt;th>学号&lt;/th> &lt;th>姓名&lt;/th> &lt;th>年龄&lt;/th> &lt;th colspan=\"2\">操作&lt;/th> &lt;/tr> &lt;tr v-for=\"(stu,index) in stus\":key=\"stu.index\"> &lt;td>&#123;&#123;index+1&#125;&#125;&lt;/td> &lt;template v-if=\"stu.edit\" > &lt;td>&lt;input type=\"text\" size=\"5\" v-model=\"stu.name\">&lt;/td> &lt;td>&lt;input type=\"text\" size=\"5\" v-model=\"stu.age\">&lt;/td> &lt;/template> &lt;template v-else> &lt;td>&#123;&#123;stu.name&#125;&#125;&lt;/td> &lt;td>&#123;&#123;stu.age&#125;&#125;岁&lt;/td> &lt;/template> &lt;td>&lt;input @click=\"edit(stu)\" :value=\"statement\" type=\"button\">&lt;/td> &lt;td>&lt;input type=\"button\" @click=\"deleteItem(index)\" value=\"删除\">&lt;/td> &lt;/tr> &lt;/table> 姓名：&lt;input type=\"text\" v-model=\"stu.name\"> 年龄：&lt;input type=\"text\" v-model=\"stu.age\"> &lt;input type=\"button\" value=\"添加\" @click=\"add(stu.name,stu.age)\"> &lt;/div> &lt;script> const root = Vue.createApp(&#123; data() &#123; return &#123; stus:[ &#123;name:'tom',age:20&#125;, &#123;name:'marry',age:18&#125;, &#123;name:'scott',age:25&#125; ], statement:\"编辑\", stu:&#123; name:'', age:'' &#125; &#125; &#125;,methods:&#123; edit(stu)&#123; if(this.statement === \"编辑\")&#123; stu.edit = true; this.statement = \"保存\"; &#125;else &#123; stu.edit = false; this.statement = \"编辑\"; &#125; &#125;, deleteItem(index)&#123; if (confirm(\"是否删除\"))&#123; this.stus.splice(index,1); &#125; &#125;, add()&#123; this.stus.push(this.stu); this.stu=&#123; name:\"\", age:\"\" &#125; &#125; &#125; &#125;).mount(\"#app\"); &lt;/script> &lt;/body> &lt;/html> 绑定复选框&lt;template v-for=\"hobby in hobbies\"> &lt;input type=\"checkbox\" v-model=\"selectedItem\" :value=\"hobby\">&#123;&#123;hobby&#125;&#125; &lt;/template> 单个复选框：使用v-model绑定一个布尔值 &lt;input type=\"checkbox\" v-model=\"isAll\"> &lt;script> Vue.createApp(&#123; data()&#123; return&#123; isAll:false//复选框被选中，isAll为true &#125; &#125; &#125;) &lt;/script> 复选框组：使用v-model绑定到一个数组，如果复选框被选中，当前复选框的值会被放到数组中，取消选择，则从数组中移除 &lt;input type=\"checkbox\" v-model=\"selectedItem\" :value=\"hobby\">&#123;&#123;hobby&#125;&#125; const root = Vue.createApp(&#123; data() &#123; return &#123; hobbies:[ \"学java\", \"玩游戏\", \"踢足球\", \"打篮球\" ], selectedItem:[ ], selectTime:false, isAll:false &#125; &#125;,methods:&#123; checkAll()&#123; // this.selectTime = !this.selectTime; if (this.isAll)&#123; this.selectedItem =[...this.hobbies]; &#125;else&#123; this.selectedItem.length = 0; &#125; &#125;, reverseAll()&#123; this.selectedItem = this.hobbies.filter(h=>&#123; //includes:查找参数元素是否存在，如果存在返回true，否则返回false return !this.selectedItem.includes(h); /*if (this.selectedItem.indexOf(h) >= 0)&#123; return false; &#125;else &#123; return true; &#125;*/ &#125;) &#125; &#125; &#125;).mount(\"#app\"); &lt;/script> 绑定单选按钮&lt;div id=\"app\"> &lt;template v-for=\"hobby in hobbies\"> &lt;input type=\"radio\" v-model=\"selectItem\" :value=\"hobby\">&#123;&#123;hobby&#125;&#125; &lt;/template> &lt;/div> &lt;script> const root = Vue.createApp(&#123; data() &#123; return &#123; hobbies:[\"阅读\",\"旅游\",\"音乐\",\"运动\"], selectItem:''//如果值为\"阅读\"，则\"阅读\"被默认选中 &#125; &#125; &#125;).mount(\"#app\"); 注意：没有给单选按钮的value赋值，默认值是on 绑定下拉列表框&lt;select v-model=\"selectProvince\" @change=\"cityChange\"> &lt;option v-for=\"province in provinces\" >&#123;&#123;province&#125;&#125;&lt;/option> &lt;/select> 省市级联综合案例&lt;!DOCTYPE html> &lt;html lang=\"zh-CN\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;script src=\"./node_modules/vue/dist/vue.global.js\">&lt;/script> &lt;/head> &lt;body> &lt;div id=\"app\"> 省份&lt;select v-model=\"selectProvince\" @change=\"cityChange\"> &lt;option v-for=\"province in provinces\" >&#123;&#123;province&#125;&#125;&lt;/option> &lt;/select> 城市&lt;select> &lt;option v-for=\"city in selectCities\">&#123;&#123;city&#125;&#125;&lt;/option> &lt;/select> &lt;/div> &lt;script> const root = Vue.createApp(&#123; data() &#123; return &#123; provinces:[\"辽宁\",'吉林','黑龙江'], selectProvince:'--请选择--', cities:new Map([ ['辽宁',['沈阳','大连','盘锦']], ['吉林',['长春','吉林']], ['黑龙江',['哈尔滨','齐齐哈尔']] ]), selectCities:[] &#125; &#125;,methods:&#123; cityChange()&#123; this.selectCities=this.cities.get(this.selectProvince) &#125; &#125; &#125;).mount(\"#app\"); &lt;/script> &lt;/body> &lt;/html> Map集合 创建map集合 let map &#x3D; new Map(); 创建并初始化map集合 let map &#x3D; new Map([[key.value],[key.value]，[key.value]，[key.value]，[key.value]...]); 添加键值对 map.set(key,value) 根据键取值 map.get(key) 移除键值对 map.delete(key) 得到键的迭代器对象 let keys = map.keys() let keys = this.map.keys(); for (let i = 0; i &lt; this.map.size; i++) &#123; this.items.push(keys.next().value) &#125; 得到值的迭代器对象 let values = map.values() let items = this.map.values() for (let i = 0; i &lt; this.map.size; i++) &#123; this.items.push(items.next().value) &#125; 得到键值对的个数 map.size 样式绑定 通过v-bind指令，绑定内联样式(行内样式)和类样式 绑定内联样式 绑定单个样式 &lt;div id=\"app\"> &lt;p :style=\"&#123;color:colorValue,fontSize:fontSizeValue&#125;\">tom&lt;/p> &lt;input type=\"button\" value=\"修改\" @click=\"changeStyle\"> &lt;/div> &lt;script> const root = Vue.createApp(&#123; data() &#123; return &#123; colorValue:'red', fontSizeValue:'15px' &#125; &#125;,methods:&#123; changeStyle()&#123; this.colorValue = 'blue' this.fontSizeValue = \"50px\" &#125; &#125; &#125;).mount(\"#app\"); &lt;/script> 绑定样式对象 &lt;div id=\"app\"> &lt;p :style=\"styleObj\">tom&lt;/p> &lt;input type=\"button\" value=\"修改\" @click=\"changeStyle\"> &lt;/div> &lt;script> const root = Vue.createApp(&#123; data() &#123; return &#123; styleObj:&#123; color:'red', fontSize:'15px' &#125; &#125; &#125;,methods:&#123; changeStyle()&#123; &#125; &#125; &#125;).mount(\"#app\"); &lt;/script> 类样式绑定 绑定单个类名 &lt;style> .class1&#123; color: red; &#125; &lt;/style> &lt;p :class=\"&#123;class1:isShow&#125;\">普通文本&lt;/p> data() &#123; return &#123; isShow:true &#125; &#125; 绑定类对象 &lt;style> .class1&#123; color: red; &#125; .class2&#123; font-size: 20px; &#125; &lt;/style> &lt;div id=\"app\"> &lt;p :class=\"classObj\">普通文本&lt;/p> &lt;/div> data() &#123; return &#123; classObj:&#123; class1:true, class2:true &#125; &#125; &#125; 绑定类数组 &lt;style> .class1&#123; color: red; &#125; .class2&#123; font-size: 50px; &#125; &lt;/style> &lt;div id=\"app\"> &lt;p :class=\"[classObj1,classObj2]\">普通文本&lt;/p> &lt;/div> data() &#123; return &#123; classObj1:&#123; class1:true &#125;, classObj2:&#123; class2:true &#125; &#125; &#125; 计算属性 定义：计算属性是基于组件的响应式依赖进行缓存的属性，只有当它的依赖发生变化时，才会重新求值 使用原因： 性能优化 逻辑清晰 基本使用 &lt;div id=\"app\"> 商品价格：&lt;input type=\"text\" v-model=\"price\"> 商品数量：&lt;input type=\"number\" v-model=\"sum\">&lt;br> 商品总价：&#123;&#123;total&#125;&#125;&lt;br> 姓名：&#123;&#123;showName&#125;&#125; &lt;/div> &lt;script> const root = Vue.createApp(&#123; data() &#123; return &#123; price:10, sum:0, name:\"tom\" &#125; &#125;,computed:&#123;//计算属性 total()&#123; return this.price*this.sum &#125;, showName()&#123; return this.name.toUpperCase(); &#125; &#125; &#125;).mount(\"#app\"); &lt;/script> 计算属性和方法 计算属性依赖缓存，只有当依赖发生变化的时候才会重新求值 监听属性 定义：监听属性允许你响应某些特定的数据变化，执行自定义的逻辑，与计算属性相似，但专为侦听数据的变化而设计 基本使用 &lt;div id=\"app\"> &lt;input type=\"text\" v-model=\"km\">千米&lt;br> &lt;input type=\"text\" v-model=\"m\">米&lt;br> &lt;/div> &lt;script> const root = Vue.createApp(&#123; data() &#123; return &#123; km:0, m:0 &#125; &#125;,methods:&#123; &#125;,computed:&#123; &#125;,watch:&#123; km(newValue,oldValue)&#123; this.m = newValue*1000; &#125;, m(newValue,oldValue)&#123; this.km = newValue/1000; &#125; &#125; &#125;).mount(\"#app\"); 为什么使用监听属性 执行异步操作或昂贵操作(计算属性无法执行异步操作，它是同步的) 可以对多个数据源进行侦听 深度监听和立即执行 &lt;div id=\"app\"> 商品价格：&lt;input type=\"text\" v-model=\"good.price\">&lt;br> 商品数量：&lt;input type=\"text\" v-model=\"good.num\">&lt;br> &#123;&#123;total&#125;&#125; &lt;/div> &lt;script> const root = Vue.createApp(&#123; data() &#123; return &#123; good:&#123; price:1, num:1 &#125;, total:'' &#125; &#125;,watch:&#123; good:&#123; handler(newValue)&#123; this.total = this.good.num * this.good.price &#125;, deep:true//深度监听，监听对象的属性 ,immediate:true//立即执行 &#125; &#125; &#125;).mount(\"#app\"); &lt;/script> 组件概述 定义：组件是Vue最强大的功能之一，组件可以扩展html元素，封装可重用的代码 目的： 代码重用 模块化 简洁性：清晰地定义界面的每个部分 基础使用： 定义组件 const myComponent &#x3D; &#123; template:&#96;&lt;div &gt;&#123;&#123;msg&#125;&#125;--&#123;&#123;count&#125;&#125;--&lt;input @click&#x3D;&quot;add&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;+&quot;&gt;&lt;&#x2F;div&gt;&#96;, data()&#123; return&#123; msg:&#39;Hello!&#39;, count:1 &#125; &#125;,methods:&#123; add()&#123; this.count++ &#125; &#125; &#125; 注册组件 局部注册 const root &#x3D; Vue.createApp(&#123; data() &#123; return &#123; &#125; &#125;, components:&#123;&#x2F;&#x2F;注册组件 组件名:组件对象 &quot;my-component&quot;:myComponent &#125; &#125;).mount(&quot;#app&quot;); 全局注册 const app &#x3D; Vue.createApp(&#123; data() &#123; return &#123; &#125; &#125;, &#x2F;&#x2F;在Vue应用对象中注册，称为全局注册 app.component(&quot;my-component&quot;,myComponent) 在父组件的模板中使用 &lt;div id=\"app\"> &lt;my-component>&lt;/my-component> &lt;/div> 组件名称注意事项： 驼峰命名：在JavaScript中使用驼峰命名法，例如:myComponent 短横线命名：在html的模板中，组件名应使用短横线命名，例如:my-component 避免使用Vue保留的前缀，如：v- Vue3父子组件通信 基本概念： 在vue中，父子组件的关系可以总结为prop down，events up(属性下传，事件上抛) 父组件通过props将数据传递给子组件 子组件通过事件向父组件发送信息 props 定义：是props是父组件用来传递数据给子组件的自定义属性 使用：在子组件中声明props属性来接收数据 &#x2F;&#x2F;子组件 &#123; name:&#39;子组件的名字&#39;, props:[&quot;num&quot;] &#125; 注意：子组件内部不应该修改prop的值 自定义事件 子组件 &#x2F;&#x2F;ChildCom.vue this.$emit(&#39;事件名&#39;,向父组件传递的数据) 父组件 //ParentCom.vue &lt;template> &lt;ChildCom @事件名=\"父组件中的方法\">&lt;/ChildCom> &lt;ChildCom @事件名=\"num=$\">&lt;/ChildCom> &lt;/template> methods:&#123; &#x2F;&#x2F;value表示子组件传递出来的值 父组件中的方法(value)&#123; &#125; &#125;,data()&#123; return&#123; num:0 &#125; &#125; $event：表示子组件传递出来的值 provide和inject 概述：主要用于避免为深层次的组件通过 props 逐层传递数据。 工作原理： provide：通过该属性暴露一些属性或方法，使其在子组件中可用 inject：任何子组件或更深层的组件可以通过 inject 选项来获取其祖先组件暴露出来的属性或方法 基本使用 父组件 provide:&#123; themeColor:&#39;blue&#39; &#125; 子组件 inject:[&#39;themeColor&#39;] 插槽 实现了一种内容分发的机制。可以使得父组件插入内容到子组件的视图结构中。 基础插槽 默认插槽：允许父组件为子组件插入内容 如果子组件没有预留出插槽，父组件的内容被忽略 子组件内容使用&lt;slot&gt;&lt;/slot&gt;来指定内容的分发位置 子组件 //ChildSlot &lt;template> &lt;div>&lt;slot>&lt;/slot>&lt;/div> &lt;/template> 父组件 &lt;ChildSlot> &lt;h1>父组件插入的内容&lt;/h1> &lt;/ChildSlot> 具名插槽 允许多个插槽的存在，需要使用name属性区分 子组件 //ChildSlot &lt;template> &lt;div>&lt;slot name=\"header\">&lt;/slot>&lt;/div> &lt;div>&lt;slot>&lt;/slot>&lt;/div> &lt;/template> 父组件 &lt;ChildSlot> &lt;template #header> 插入到名称为header的子组件插槽 &lt;/template> &lt;h1>父组件插入的内容&lt;/h1> &lt;/ChildSlot> 作用域插槽 允许子组件为插槽传递数据 子组件 //ChildSlotScope data()&#123; return &#123; num:100, name:'tom' &#125; &#125; &lt;template> &lt;slot :n=\"num\" :username=\"name\">&lt;/slot> &lt;slot name=\"header\" :n=\"num\">&lt;/slot> &lt;/template> 父组件 &lt;ChildSlotScope> &lt;template #default=\"slotScope\"> 数量：&#123;&#123;slotScope.n&#125;&#125;,用户名：&#123;&#123;slotScope.username&#125;&#125; &lt;/template> &lt;template #header=\"slotScope\"> 数量：&#123;&#123;slotScope.n&#125;&#125; &lt;/template> &lt;/ChildSlotScope> Vite概述 Vite是什么？ Vite(法语中的”快”)，是一个由Vue.js的创建者尤雨溪开发的Web开发构建工具，旨在提供更快的冷启动时间 它不同于传统的工具如Webpack，Vite利用了ES6的原生模块系统(ESM)进行快速的源码到源码的转换 基础使用 npm create vite@latest npm create vite@latest 项目名 -- --template vue Vite中vue项目目录结构 index.html:这是应用的主html文件，它是Vite开发服务器的入口点，并且也是构建后的应用的入口点 package.json:这个文件包含了项目的元数据，例如：项目的名称，版本，依赖 package-lock.json:是自动生成的，用于描述项目的依赖树结构的文件,当在项目中安装或更新依赖时，这个文件会自动更新 src&#x2F;:这个目录包含了应用的所有源文件，包括Vue组件、JavaScript文件和其他资源 assets:这个目录是用于存放静态资源，如图片，字体等 components：这里通常存放vue组件文件 App.vue：主Vue组件文件，通常会包括应用的布局和样式 vite.config.js：自定义的vite配置放到这里 路由概述 介绍 Vue Router是Vue.js官方的路由管理器，它与Vue.js的核心深度集成，简化单页面应用的开发 安装 npm install vue-router@4 基本使用 创建路由对象 &#x2F;&#x2F;src&#x2F;router&#x2F;index.js import &#123;createRouter,createWebHistory&#125; from &quot;vue-router&quot;; &#x2F;&#x2F;路由表 const routes&#x3D;[ &#123; path:&quot;&#x2F;login&quot;, name:&quot;login&quot;, component:()&#x3D;&gt; import(&quot;..&#x2F;views&#x2F;Login.vue&quot;) &#125;,&#123; path:&quot;&#x2F;main&quot;, name:&quot;main&quot;, component:()&#x3D;&gt;import(&quot;..&#x2F;views&#x2F;main.vue&quot;) &#125; ] &#x2F;&#x2F;创建一个路由器对象 const router&#x3D;createRouter(&#123; history:createWebHistory(import.meta.env.BASE_URL), routes &#125;) export default router; 在主应用中使用 //main.js import &#123; createApp &#125; from 'vue' // import './style.css' import router from \"./router/index.js\";//导入路由器对象 import App from './App.vue' createApp(App).use(router).mount('#app')//在vue应用中注册路由插件 在App.vue组建中添加&lt;router-view&gt;&lt;/router-view&gt; 路由传参 使用路由路径参数 &#123; path:&#39;editDept&#x2F;:deptno&#39; &#125; &#x2F;&#x2F;使用params传参，不能使用path属性 &lt;router-link :to&#x3D;&quot;&#123;name:&#39;editdept&#39;,params:&#123;deptno:dept.deptno&#125;&#125;&quot;&gt;&lt;&#x2F;router-link&gt; &#x2F;&#x2F;得到数据 &#123;&#123;$route.params.deptno&#125;&#125; &#x2F;&#x2F;地址栏 http:&#x2F;&#x2F;localhost:5173&#x2F;main&#x2F;editdept&#x2F;10 实用查询参数 不需要在路由配置中预先定义查询参数 &#123; path:&#39;editdept&#39; &#125; &lt;router-link :to&#x3D;&quot;&#123;name:&#39;editdept&#39;,query:&#123;deptno:dept.deptno&#125;&#125;&quot;&gt;&lt;&#x2F;router-link&gt; &#x2F;&#x2F;地址栏 http:&#x2F;&#x2F;localhost:5173&#x2F;main&#x2F;deptModify?deptno&#x3D;10&amp;dname&#x3D;人力资源部 编程式路由 导航的两种方式 声明式导航：通过&lt;router-link&gt;标签 编程式导航：通过Vue-router提供的api来实现 router.push() 会向路由的历史记录中添加一个新的记录 $router.push(&quot;&#x2F;main&quot;) $router.push(&#123;name:&#39;dept&#39;,query:&#123;deptno:Deptno&#125;&#125;) router.replace() 跟push()类似，但它不会向历史记录中添加新纪录，而是替换掉当前记录 router.go(n) 在历史记录中来回跳转 this.$router.go(-1)后退一页 this.$router.go(1)前进一页 路由守卫主要用于监视路由的变化，可以执行某些操作，例如：权限检查，页面跳转 router.beforeEach((to,from,next)&#x3D;&gt;&#123; if (to.path !&#x3D; &#39;&#x2F;&#39; &amp;&amp; to.path !&#x3D; &#39;&#x2F;login&#39;)&#123; const user &#x3D; sessionStorage.getItem(&quot;user&quot;); if (!user)&#123; next(&quot;&#x2F;login&quot;)&#x2F;&#x2F;跳转回登录页 &#125;else &#123; next(); &#125; &#125; next();&#x2F;&#x2F;放行 &#125;) beforeEach():允许在路由变化之前设置一个钩子函数 {to,from,next}&#x3D;&gt;{} to:路由对象，表示即将导航到的目的路由对象 from:表示从哪个路由导航而来 next:是一个函数 next(‘&#x2F;login’):拦截，跳转到指定路径 next(false):将中断导航 路由监听使用watch选项来监听某个路由的变化 &#x2F;&#x2F;APP.vue watch:&#123; $route(to,from)&#123; if (to.name &#x3D;&#x3D;&#x3D; &quot;deptModify&quot; &amp;&amp; from.name &#x3D;&#x3D;&#x3D; &quot;dept&quot;)&#123; alert(&quot;即将跳转&quot;) &#125; &#125; &#125; 组件的生命周期描述了组件从被创建到被销毁的整个过程，我们可以使用”钩子”在关键时刻插入自定义的代码 beforeCreate和created beforeCreate：组件实例创建之前执行的方法 created：组件实例创建完毕 beforeMount和mounted beforeMount：当组件挂载之前执行 mount：组件被挂载到DOM上 beforeUpdate和updated beforeUpdate：当响应式数据发生变化，组件需要更新之前 update：组件模板已经更新,数据变化后 beforeDestory和destroyed beforeDestory:组件销毁前执行 destroyed：组件被销毁后执行 Vuex 介绍 是vue.js的状态管理库 安装 npm install vuex@next --save 配置 &#x2F;&#x2F;src&#x2F;store&#x2F;index.js import &#123;createStore&#125; from &quot;vuex&quot;; const store &#x3D; createStore(&#123; state()&#123; return&#123; count:0 &#125; &#125; &#125;) export default store 在Vue应用对象中注册插件 &#x2F;&#x2F;main.js import store from &quot;.&#x2F;store&#x2F;index.js&quot;; createApp(App).use(router).use(store).mount(&#39;#app&#39;) 在vue组件中 &#123;&#123;$store.state.count&#125;&#125; this.$store.state.count 改变状态 不能直接改变store中的状态，修改store中的状态的唯一途径就是显示的提交(commit) mutation const store &#x3D; createStore(&#123; state()&#123; return&#123; count:0 &#125; &#125;, mutations:&#123; increment(state)&#123; state.count++ &#125; &#125; &#125;) &#x2F;&#x2F;代码 this.$store.commit(&#39;increment&#39;) getters 从store中的state派生出一些状态 import &#123;createStore&#125; from &quot;vuex&quot;; const store &#x3D; createStore(&#123; state()&#123; return&#123; count:0 &#125; &#125;, mutations:&#123; increment(state,num)&#123; state.count +&#x3D; num &#125; &#125;, getters:&#123; count2: state &#x3D;&gt; state.count+&quot;个&quot; &#125; &#125;) &#x2F;&#x2F;模板中 &#123;&#123;$store.getters.count2&#125;&#125; Actions Action可以包含任意异步操作 Action提交时是mutation而不是直接修改状态 import &#123;createStore&#125; from &quot;vuex&quot;; const store &#x3D; createStore(&#123; state()&#123; return&#123; count:0 &#125; &#125;, mutations:&#123; increment(state,num)&#123; state.count +&#x3D; num &#125; &#125;, getters:&#123; count2: state &#x3D;&gt; state.count+&quot;个&quot; &#125;, actions:&#123; add(context)&#123; setTimeout(function ()&#123; context.commit(&#39;increment&#39;,2) &#125;,3000) &#125; &#125; &#125;) export default store 组合式API概述是Vue3新引入的一种编写组件逻辑的方式，与Vue2的选项式API相比，提供了更加灵活的代码组织方式 set()函数&lt;script> import &#123;ref&#125; from \"vue\"; export default &#123; setup()&#123; let num = ref(10); let name = ref(\"tom\") function test()&#123; num.value++; name.value = \"marry\" &#125; return &#123; num, test, name &#125; &#125; &#125; &lt;/script> &lt;template> &#123;&#123;num&#125;&#125; &#123;&#123;name&#125;&#125; &lt;input type=\"button\" @click=\"test\" value=\"test\"> &lt;/template> &lt;style scoped> &lt;/style> &lt;script setup&gt;&lt;script setup> import &#123;ref&#125; from \"vue\"; let num = ref(10); let name = ref(\"tom\") function test()&#123; num.value++ name.value = \"marry\" &#125; &lt;/script> &lt;template> &#123;&#123;num&#125;&#125; &#123;&#123;name&#125;&#125; &lt;input type=\"button\" @click=\"test\" value=\"test\"> &lt;/template> &lt;style scoped> &lt;/style> ref和reactive ref：用于将原始数据类型(如：string、number)转化为响应式对象 返回的对象有一个value属性，通过这个属性可以获取或设置其值 reactive：用于创建一个响应式对象 对于对象和数组，可以直接使用它们，无需.value 不能直接包装原始数据类型 import &#123;reactive, ref&#125; from &quot;vue&quot;; const obj &#x3D; reactive( &#123; age:10, arr:[1,2,3], scores:[ &#123;name:&#39;数学&#39;,score:100&#125;, &#123;name:&#39;语文&#39;,score:90&#125;, &#123;name:&#39;英语&#39;,score:80&#125;, ] &#125; ) const arr&#x3D;reactive([ &#123;name:&#39;数学&#39;,score:100&#125;, &#123;name:&#39;语文&#39;,score:90&#125;, &#123;name:&#39;英语&#39;,score:80&#125;, ]) const arr2 &#x3D;ref( &#123; count:10, name:&#39;tom&#39; &#125; ) function change()&#123; &#x2F;&#x2F; obj.age++; &#x2F;&#x2F; obj.arr[0]++; &#x2F;&#x2F; obj.scores[0].score--; &#x2F;&#x2F; arr[0].score-- arr2.value.count++ &#125; 计算属性let total &#x3D; computed(()&#x3D;&gt;price.value*num.value) props//子组件 let props = defineProps(['name','num']) &#123;&#123;props.name&#125;&#125;--&#123;&#123;props.num&#125;&#125; //父组件 &lt;ChildTest name='tom' num='18'>&lt;/ChildTest> defineEmits&#x2F;&#x2F;子组件 let emits &#x3D; defineEmits([ &#39;event1&#39;,&#39;event2&#39; ]) function toParent()&#123; emits(&#39;event1&#39;,100) emits(&quot;event2&quot;,200) &#125; //父组件 &lt;script setup> import ChildTest from \"./ChildTest.vue\" import &#123;ref&#125; from \"vue\"; let num = ref(0) &lt;/script> &lt;template> &lt;ChildTest name=\"tom\" num=\"18\" @event2=\"num = $event\">&lt;/ChildTest> &#123;&#123;num&#125;&#125; &lt;/template> &lt;style scoped> &lt;/style> 生命周期钩子函数 没有对应的created函数，原来在created事件发生事后执行的代码直接写到script标签中 function showHi()&#123; alter(&quot;Hi&quot;) &#125; showHi(); onMounted onMounted(() &#x3D;&gt;&#123; alter(&quot;Hi&quot;) &#125;) 大多数生命周期的钩子函数都是在原来函数前加on，特殊的如：destroyed和beforeDestroyed用onUnmounted和onBeforeUnmount替代 监听器let km &#x3D; ref(0) let m &#x3D; ref(0) watch(km,(newValue,oldValue)&#x3D;&gt;&#123; m.value &#x3D; km.value * 1000 &#125;) watch(m,()&#x3D;&gt;&#123; km.value &#x3D; m.value &#x2F; 1000 &#125;) 补充在Vite中动态使用图片import imgSrc from &#39;..&#x2F;assets&#x2F;vue.svg&#39; &lt;img :src&#x3D;&quot;imgSrc&quot;&gt; 1.","categories":[{"name":"VUE","slug":"VUE","permalink":"http://yiyecreb.top/categories/VUE/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"ES6","slug":"ES6","date":"2023-08-27T16:00:00.000Z","updated":"2023-08-29T03:14:04.016Z","comments":true,"path":"2023/08/28/ES6/","link":"","permalink":"http://yiyecreb.top/2023/08/28/ES6/","excerpt":"","text":"ES6概述 ESCAScript6.0(简称ES6)，是JavaScript语言的下一代标准，在2015年6月正式发布 目标:用来编写复杂大型的应用程序，称为企业级的开发语言 ES6编程基础var问题: ES5只有全局作用域和函数作用域，没有块级作用域 在编译时会有一个变量提升的效果，并对提升的变量赋予了默认值undefined var tmp &#x3D; 100; function fn()&#123; document.write(tmp); if (false)&#123; var tmp &#x3D; 10; &#125; &#125; fn(); let命令用于声明块级作用域的局部变量的关键字 基础用法let x &#x3D; 10; if (true)&#123; let x &#x3D; 20; document.write(x); &#125; document.write(x); 作用域：与var关键字不同，let声明的变量仅在最接近的一对大括号&#123;&#125;内有效 不能重复声明 暂时性死区:在变量声明前的这段代码区域，称为暂时性死区 暂时性死区中，变量不能使用 let有提升的效果，但是不像var声明的变量名被初始化为undefined,let提升后没有初始值，所以不能使用 不绑定全局变量 在全局作用域中用let声明的变量不会成为window对象的属性 let x &#x3D; 10; document.write(window.x);&#x2F;&#x2F;undefined const命令const用于声明一个不可以重新赋值的变量 const x = 10; x = 100;//报错 const obj = &#123; age:20 &#125; obj.age = 30;//不报错 obj = &#123; age:30 &#125;//报错 解构赋值用于提取数组或对象中的数据，并赋值给变量 数组解构let arr &#x3D; [1,2,3]; const[a,b,c] &#x3D; arr; const[a,,c]&#x3D;arr; 对象解构let obj &#x3D; &#123; name:&#39;tom&#39;, age:20 &#125; let &#123;name:n,age&#125; &#x3D; obj;&#x2F;&#x2F;n指别名 let obj &#x3D; &#123; name:&#39;tom&#39;, age:20, scores:&#123; math:100, chinese:90 &#125; &#125; let &#123;name,age,scores:&#123;math,chinese&#125;&#125; &#x3D; obj; document.write(name+&quot;&lt;br&gt;&quot;+age+&quot;&lt;br&gt;&quot;+math+&quot;&lt;br&gt;&quot;+chinese) 函数参数解构function greet(&#123;name,age&#125;)&#123; return `我的姓名是：$&#123;name&#125;,我的年龄是：$&#123;age&#125;`; &#125; let s = greet(&#123;name:'tom',age:20&#125;); document.write(s) 函数的扩展——rest参数(剩余参数)rest参数允许将一个不定数量的参数表示为一个数组，rest参数在函数参数的最后一个位置，前面有一个...作为前缀 function sum(...arr)&#123; let sum = 0; for (let n of arr) &#123; sum += n; &#125; return sum; &#125; let number = sum(1,2,3); document.write(number);/ 扩展运算符(展开运算符)定义：用于将一个数组或可迭代对象(如：字符串)展开到由0个或多个参数组成的列表中 数组中使用：const arr1 &#x3D; [1,2,3]; const arr2 &#x3D; [4,5,6,7]; &#x2F;&#x2F;合并 const arr &#x3D;[...arr1,...arr2]; document.write(arr.toString()); &#x2F;&#x2F;克隆 const arr1 &#x3D; [1,2,3]; const arr &#x3D; [...arr1]; document.write(arr.toString()) &#x2F;&#x2F;展开数组作为函数的参数 function sum(x,y,z)&#123; return x+y+z; &#125; let sum1 &#x3D; sum(...nums); document.write(sum1); 对象中使用：&#x2F;&#x2F;合并两个对象 let obj1 &#x3D; &#123;name:&#39;tom&#39;,sex:&#39;男&#39;&#125;; let obj2 &#x3D; &#123;age:&#39;20&#39;&#125;; let obj &#x3D; &#123;...obj1,...obj2&#125;; document.write(obj.name+&quot; &quot;+obj.age+&quot; &quot;+obj.sex); &#x2F;&#x2F;克隆对象 let obj2 &#x3D; &#123;...obj1&#125;; document.write(obj2.name+&quot; &quot;+obj2.sex); 增强版的对象字面量 属性名简写 const name &#x3D; &quot;tom&quot; , age &#x3D; 20; const obj &#x3D; &#123;name:name,age:age&#125;;&#x2F;&#x2F;未简写 const obj &#x3D; &#123;name,age&#125;;&#x2F;&#x2F;简写 计算属性名：使用表达式作为属性名 const propName &#x3D; &#39;name&#39;; const obj &#x3D; &#123; [propName]:&#39;tom&#39; &#125; document.write(obj.name); 简写方法名 &#x2F;&#x2F;ES5 const obj &#x3D; &#123; name:&#39;tom&#39;, sayHi:function()&#123; &#125; &#125; &#x2F;&#x2F;ES6 const obj &#x3D; &#123; name :&#39;tom&#39;, sayHi()&#123; &#125; &#125; 箭头函数基础语法 无参数:如果没有参数，也需要使用一对空括号 const sayHi &#x3D; ()&#x3D;&gt;&#123;return &#39;hello&#39;&#125;; 单个参数:可以省略括号 const sayHi &#x3D; name&#x3D;&gt;&#123;return &#96;hello!$&#123;name&#125;&#96;&#125;; 多参数:用括号括起来 const sum &#x3D; (x,y) &#x3D;&gt;&#123;return x+y&#125; 函数体 简化函数体(单表达式):对于只包含一个表达式的函数体，可以直接返回结果，无需return const sum &#x3D; (x,y) &#x3D;&gt; &#123;return x+y&#125; &#x2F;&#x2F;简化 const sum &#x3D; (x,y) &#x3D;&gt; x+y; 完整函数体(多条语句):需要使用大括号，并显示使用return const sum &#x3D; (x,y)&#x3D;&gt;&#123; let result &#x3D; x + y; return result; &#125; 不具备arguments对象let sum &#x3D; (...arr)&#x3D;&gt;&#123; &#x2F;&#x2F;箭头函数没有arguments对象 document.write(arr) &#125; sum(1,2,3,4); this的行为箭头函数没有自己的this，它会捕获其所在上下文的this值作为自己的this值。这是箭头函数最重要的特点 function test()&#123; console.log(this)&#x2F;&#x2F;&#123;name:&#39;tom&#39;&#125; let t; &#x2F;* t &#x3D; function ()&#123; console.log(this) &#125;*&#x2F; t&#x3D;()&#x3D;&gt;&#123; console.log(this)&#125;;&#x2F;&#x2F;&#123;name:&#39;tom&#39;&#125; t(); &#125; let stu &#x3D;&#123;name:&quot;tom&quot;&#125; stu.test &#x3D; test; stu.test(); 模块化 ES6模块的主要思想是必须显示地使用标识符导出模块数据，才能从外部访问模块 导入导出方式一：要求导入的时候使用导出时候的名称 &#x2F;&#x2F;js&#x2F;1.js export var x &#x3D; 100; &#x2F;&#x2F;demo12.html import &#123;x&#125; from &#39;.&#x2F;js&#x2F;1.js&#39; document.write&#x2F;&#x2F;模块是异步加载的 默认导出导入 &#x2F;&#x2F;.&#x2F;3.js export default &#123; name:&#39;tom&#39; &#125;; const x &#x3D; 100; function sum(num1,num2)&#123; return num1+num2; &#125; export &#123;x,sum&#125;; &lt;!--index.html--> &lt;script type='module'> import obj,&#123;x,sum&#125; from './3.js' console.log(obj.name,x,sum(1,2)); &lt;/script> 全部导入 import * as app from &#39;.&#x2F;3.js&#39; console.log(app.default.name); console.log(app.x); console.log(app.sum(1,2)); 注意:模块内的方法的作用域就是当前模块，不是全局作用域 import &#123;sayHi&#125; from &#39;.&#x2F;3.js&#39; &#x2F;&#x2F;DOMContentLoaded:在html文件被完全加载和解析完成后触发，不等待样式表和图像，子框架的完成 &#x2F;&#x2F;异步加载的模块会在DOMContentLoaded时间执行前加载完成 document.addEventListener(&#39;DOMContentLoaded&#39;,function ()&#123; window.sayHi &#x3D; sayHi; document.querySelector(&quot;[value&#x3D;&#39;测试&#39;]&quot;).addEventListener(&quot;click&quot;,sayHi); &#125;); 面向对象构造函数 定义:用于创建和初始化一个对象的特殊函数 定义构造函数 function Person(name,age)&#123; this.name&#x3D;name; this.age&#x3D;age; &#125; 使用new关键字创建对象 const p &#x3D; new Person(&#39;tom&#39;,20) 访问属性 document.write(p.name); 注意: 使用大写的字母开始的函数名表示这是一个构造函数 使用new关键字调用函数 this关键字表示在构造函数之内指向新创建的对象 原型(prototype) 定义:JavaScript中的每个对象都有一个与之关联的”原型”对象，从该原型对象继承属性和方法 定义原型对象 Person.prototype.sayHi &#x3D; function()&#123; document.write(&quot;hi&quot;) &#125; 通过原型添加的方法可以被所有实例共享 const p &#x3D; new Person(&#39;tom&#39;,20); p.sayHi();&#x2F;&#x2F;现在p对象内部查找sayHi()方法，如果没有就回到prototype中查找 类在ES6中，js引入了类的概念，使得面向对象编程更加直观和简单，类在js中实际上是基于原型的继承的语法 定义类class Person&#123; constructor(name,age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; sayHi()&#123; console.log(&quot;Hi&quot;) &#125; &#125; 创建实例const p &#x3D; new Person(&#39;tom&#39;,18); 调用方法p.sayHi(); 继承class Student extends Person&#123; constructor(name,age,score) &#123; super(name,age); this.score &#x3D; score; &#125; &#125; const stu &#x3D; new Student(&#39;Marry&#39;,18,99); console.log(stu.name,stu.age,stu.score); stu.sayHi(); 静态方法只能在类上调用，不能通过实例调用 class Person&#123; constructor(name,age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; static sayHi()&#123; console.log(&quot;Hi&quot;) &#125; &#125; Person.sayHi();","categories":[{"name":"H5&CSS3","slug":"H5-CSS3","permalink":"http://yiyecreb.top/categories/H5-CSS3/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"JavaScript","slug":"JavaScript","date":"2023-08-21T16:00:00.000Z","updated":"2023-08-28T02:36:12.966Z","comments":true,"path":"2023/08/22/JavaScript/","link":"","permalink":"http://yiyecreb.top/2023/08/22/JavaScript/","excerpt":"","text":"JavaScript概述 用途:为html页面添加交互行为 执行:解释器，也称为JavaScript引擎，是浏览器的一部分 位置:通常直接嵌入到html页面中 开发工具:任何一个网页开发工具都可以 特点: 脚本语言:没有预先编译的过程 弱类型，非强类型，定义变量的时候，不用指定变量的类型，变量的类型根据值的类型来决定 跨平台:不依赖于操作系统 注意: 不同的浏览器中使用该脚本编程可能会有差异 要遵循W3C DOM标准，兼容性好 历史 1995网景(NetScape) 是ECMAScript标准的一种实现 最新版ES6 编写JavaScript 把JavaScript代码写在&lt;script&gt;标签中 &lt;script&gt;标签可以写在网页的任何位置 严格区分大小写 变量 声明变量 var a; var b = 10; 向未声明的变量赋值，变量会自动声明 c &#x3D; 20; 再次声明变量，变量的值不会重置或清除 var b &#x3D; 10; var b; 输出的三种方式 alert(内容) document.write(内容) console.log(内容) 如果一条语句独占一行，可以省略该语句后的分号 五种原始数据类型 undefined:为初始化变量的值，值只有一个:undefined boolean:值true和false number:表示整数和浮点数、 string:表示字符串类型，值可以使用单引号或双引号 null类型:唯一值null，输出变量的类型如果typeof null，输出object 类型转换 parseInt(value):把一个变量强制转换为整数 parseInt(3.14);&#x2F;&#x2F;3 parseInt(&quot;3.14&quot;);&#x2F;&#x2F;3 parseInt(&quot;3.14abc&quot;);&#x2F;&#x2F;3 parseInt(&quot;a3.14&quot;);&#x2F;&#x2F;NaN:not a number,不是一个数字 parseFloat(value):把一个变量强制转换为浮点数 parseFloat(&quot;3.14&quot;);&#x2F;&#x2F;3.14 parseFloat(&quot;3.14aaaaa&quot;);&#x2F;&#x2F;3.14 parseFloat(&quot;a3.14&quot;);&#x2F;&#x2F;NaN Number(value):把一个变量强制转换为整数，它转换整个值而不是部分值 Number(&quot;3.14a&quot;)&#x2F;&#x2F;NaN 运算符 算术运算符:+-*&#x2F;%++– 赋值运算符:&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; 逻辑运算符:&amp;&amp; || ! 比较运算符:&#x3D;&#x3D;,!&#x3D;,&lt;,&gt; 三元运算符: 表达式1 ? 表达式2 : 表达式3 ==和=== ==:等于，它进行抽象比较，类型不同时，js会尝试进行类型转换，然后比较转换后的值，可能导致一些非预期的结果 0 &#x3D;&#x3D; false &#x2F;&#x2F;true 0 &#x3D;&#x3D; &#39;0&#39; &#x2F;&#x2F;true null &#x3D;&#x3D; undefined &#x2F;&#x2F;true ===:全等，在比较的时候不进行类型转换，类型不同，直接返回false 函数语法function 函数名(参数列表)&#123; 语句: return 值; &#125; 调用方式 在script标签中直接调用 在其他函数中调用 通过事件调用 function sum()&#123; &#125; &#x2F;&#x2F;onclick 单击事件，等号右边是该事件的处理程序 &lt;input type&#x3D;&quot;button&quot; onclick&#x3D;&quot;sum()&quot;&gt; eval(字符串表达式):能够对表达式进行解析并求值返回 通过超链接调用 &lt;a href=\"#\" onclick=\"compare('+')\">求和&lt;/a> &lt;a href=\"javascript:compute('+')\">求和&lt;/a> 得到文本框的值 通过元素的id获得元素对象 document.getElementById(&quot;id值&quot;) 通过表单元素名得到元素对象 document.forms[i].表单名 &lt;form&gt; &lt;input name &#x3D;&quot;num1&quot;&gt; &lt;&#x2F;form&gt; arguments对象 js的函数可以接收任意多个参数，通过arguments对象来访问 该对象类似于数组，可以使用下标来访问，例如arguments[0] 使用arguments对象的length属性，得到方法调用时候，传递过来的参数个数 使用函数名对象的length属性，得到该对象方法定义的时候，命名参数的个数(形参的个数) function method1(a,b)&#123; arguments.length;&#x2F;&#x2F;3 &#125; method1(1,2,3); method1.length;&#x2F;&#x2F;2 javascript中没有重载的概念 如果定义了两个同名的方法，下面的方法会把上面定义的同名方法覆盖 函数是对象，函数名是对象的引用function test1()&#123; alert(&#39;hi&#39;); &#125; var a &#x3D; test1; a(); 函数表达式&#x2F;&#x2F;符号的右边是一个匿名函数 var test2 &#x3D; function()&#123; alter(&#39;hi&#39;); &#125; test2(); 引用外部JS文件 定义外部文件 在html文件中引用 &lt;script src=\"./js/js.js\"> &lt;/script> Window.onload 该事件在当前html文档加载完成的时候被调用 window.onload = function()&#123; document.getElementById(\"id1\").value = \"Hello\"; &#125; 数组 定义:在单个对象中存储多个值 构造函数 Array()：返回一个长度为0的数组对象 Array(size):返回具有指定个数的数组，元素的初始值都是undefined Array(元素列表):用元素列表初始化数组，元素可以是任意类型 直接初始化数组 var arr &#x3D; [3,5,true]; 数组的长度不固定，赋值即可改变数组的长度 length:数组的长度，不是只读的，可以改变 使用下标来访问元素 遍历 fori遍历 for(var i &#x3D; 0 ; i &lt; arr.length; i++)&#123; document.write(arr[i]+&quot; &quot;); &#125; for each(下标版) for(var i in arr)&#123; document.write(arr[i]+\" \"); &#125; for each for(var i of arr)&#123; document.write(n+\" \"); &#125; 常用方法 concat(array):返回一个新数组，由当前数组和参数数组连接而成 join(分隔符):返回字符串，由数组中所有元素连接而成，元素间使用分隔符隔开 字符串.split(分隔符): 根据参数指定的分隔符，把当前字符串转换为数组 reverse():返回一个新数组，原来的数组倒置而成 sort():按照字母顺序对数组中的元素进行排序 sort(比较函数):根据参数中的函数进行比较元素的大小 var arr &#x3D; [1,3,4,5,10,20] arr.sort(function(x,y)&#123; return x - y; &#125;); push(值的列表):把值的列表追加到数组的其他元素后 indexOf(值,fromIndex),从fromIndex索引号开始，查找值的对应的索引号，找到返回索引，没有找到返回-1 lastIndexOf(值):查找参数值最后一次出现的位置 pop():移除数组中的最后一个元素，并返回该元素 shift():移除数组中的第一个元素，并返回该元素 splice(index,howmany,element…):用于向数组中添加删除替换元素 index：必需，从何处添加和删除或替换元素 howmany：必需，规定删除元素的个数，添加的时候，该值为0 element…:元素列表，可选，添加和替换的时候使用 slice(beginIndex,endIndex):返回一个新数组为原数组的截取 toString:返回将数组中元素转换为由逗号分隔的字符串 Date对象构造函数 Date():表示浏览器当前日期 Date(year,month,date):根据参数的年月日常见日期对象，month从0开始 Date(“year-month-date hour:minute:second”):根据指定的字符串格式创建日期对象，month从1开始 Date(时间戳):根据时间戳创建日期对象，时间戳:从1970年1月1日0:00:00以来的毫秒数 补充: 模板字符串:使用反引号而不是单引号或双引号来表示一个字符串 作业:可以在模板字符串中使用$(表达式)这种方式，把表达式的值接到字符串中 var d &#x3D;new Date(); var year &#x3D;d.getFullYear() var month &#x3D;((d.getMonth()+1)+&#39;&#39;).padStart(2,&#39;0&#39;) var date&#x3D;d.getDate() var hours&#x3D;(d.getHours()+&#39;&#39;).padStart(2,&#39;0&#39;) var minutes&#x3D;(d.getMinutes()+&#39;&#39;).padStart(2,&#39;0&#39;) var seconds&#x3D;d.getSeconds() document.write(&#96;$&#123;year&#125;年$&#123;month&#125;月$&#123;date&#125;日$&#123;hours&#125;时$&#123;minutes&#125;分$&#123;seconds&#125;秒&#96;) 字符串.padStart(占用的长度,填充的字符):在字符串前面根据参数补充上相应的字符 常用函数 getFullYear():得到年 getMonth():得到月 getDate():得到日 getHours():得到小时 getMinutes():得到分钟 getSeconds():得到秒 setXXX():设置时间部分 toLocalDateString():把当前Date对象转换为本地日期的字符串 定时器 setInterval(匿名函数或”函数名()”.时间间隔):用每隔指定的毫秒数重复执行一个指定的函数 setInterval(&quot;showTime()&quot;,1000); 补充 document.querySelector(css选择器):通过css选择器获得想要的元素 clearInterval(t);&#x2F;&#x2F;关闭定时器 setTimeout(匿名函数或”函数名()”.时间间隔),用于在指定的毫秒后执行一次指定的函数 clearTimeout(t);&#x2F;&#x2F;停止未运行的定时器(停止预约的定时器) 事件处理 event对象:事件对象，在事件发生的时候，由系统创建 属性:key,字符串类型，表示按键的字母 &#x2F;&#x2F;onkeydown:按键被按下时候触发 document.onkeydown &#x3D; function(event)&#123; if (event.key &#x3D;&#x3D;&#x3D; &quot;Enter&quot;)&#123; let t &#x3D; setInterval(&quot;showTime()&quot;,1000); &#125; if (event.key &#x3D;&#x3D;&#x3D; &quot; &quot;)&#123; clearInterval(t); &#125; &#125; document.addEventListener(&quot;keydown&quot;,function (event) &#123; var key &#x3D; event.key; if (key &#x3D;&#x3D;&#x3D; &quot;Enter&quot;)&#123; t &#x3D; setInterval(&quot;showTime()&quot;,1000) &#125; if (key &#x3D;&#x3D;&#x3D; &quot; &quot;)&#123; clearInterval(t); &#125; &#125;) 事件处理方式 当父元素和子元素都添加了相同的事件处理程序，先调用谁的事件处理程序 事件冒泡:先调用子程序的事件处理程序，在调用父元素的 事件捕获:先调用父元素的事件处理程序，再调用子元素 document.querySelector(&quot;div&quot;).addEventListener(&quot;click&quot;,function()&#123; alert(&quot;div&quot;); &#125;,true);&#x2F;&#x2F;true:表示父元素先捕获再传递给子元素 document.querySelector(&quot;p&quot;).addEventListener(&quot;click&quot;,function()&#123; alert(&quot;p&quot;) &#125;) 取消事件冒泡 document.querySelector(&quot;p&quot;).addEventListener(&quot;click&quot;,function(event)&#123; alert(&quot;p&quot;) event.cancelBubble &#x3D; true;&#x2F;&#x2F;取消事件冒泡 &#125;) 阻止浏览器的默认行为 document.addEventListener(&quot;contextmenu&quot;,function (event)&#123; event.preventDefault();&#x2F;&#x2F;取消右键 &#125;) Math random():生成一个0到1之间的随机小数，不能等于1 round():四舍五入 补充 document.querySelector(&quot;选择器&quot;):得到所有匹配选择器的元素中的第一个 document.querySelectorAll(&quot;选择器&quot;):得到所有匹配选择器的元素 2. ~~~JavaScript innerText:设置元素文本内容 textContent:设置元素文本内容 innerHTML:设置元素内容，对内容中的html标签会进行解析 String 构造方法 var s &#x3D; new String(&quot;Hello&quot;); 直接使用字符串字面量 var s &#x3D; &quot;Hello&quot;; length:得到字符串中字符的个数 常用方法 charAt(index):得到索引号为index的字符,index从0开始 substring(startIndex,endIndex):求子串 indexOf(查找的串):查找第一次出现的位置索引号，没有返回-1 lastIndexOf(查找的串):查找最后一次出现的位置索引号，没有返回-1 replace(str1,str2):返回一个新的字符，把原来字符串中的第一个str1替换为str2 replaceAll(str1,str2):返回一个新的字符，把原来字符串中的str1替换为str2 toUpperCase():转换为大写字符 toLowerCase():转换为小写字符 表单验证 定义:在表单数据提交给服务器之前，对html表单中的数据进行验证(格式),如果错误，则拦截，不提交 作用: 在客户端验证，速度快 减轻服务器压力 验证过程 编写页面 &lt;form action=\"Login\" onsubmit=\"return checkForm()\"> &lt;table> &lt;tr> &lt;td>用户名:&lt;/td> &lt;td>&lt;input type=\"text\" name=\"username\">&lt;/td> &lt;/tr> &lt;tr> &lt;td>密码:&lt;/td> &lt;td>&lt;input type=\"password\" name=\"password\">&lt;/td> &lt;/tr> &lt;tr> &lt;td colspan=\"2\"> &lt;input type=\"submit\" value=\"登录\"> &lt;/td> &lt;/tr> &lt;/table> &lt;/form> 编写验证函数 function checkForm() &#123; if(checkUsername() &amp; checkPassword())&#123; return true; &#125; return false; &#125; function checkUsername() &#123; let username = document.querySelector(\"[name='username']\").value; if(username.trim() === \"\")&#123; alert(\"用户名不能为空\"); return false; &#125; if(username.trim().length &lt; 3)&#123; alert(\"用户名长度不能小于3\"); return false; &#125; return true; &#125; function checkPassword() &#123; let password = document.querySelector(\"[name='password']\").value; if(password.trim() === \"\")&#123; alert(\"密码不能为空\"); return false; &#125; if (password.trim().length &lt; 7)&#123; alert(\"密码不能少于七位\"); return false; &#125; let num = 0; for (let i = 'a' ; i &lt;'z' ; i++)&#123; if (password.trim().indexOf(i) >= 0)&#123; num++; &#125; &#125; for (let i = 'A' ; i &lt; 'Z' ; i ++)&#123; if (password.trim().indexOf(i) >= 0)&#123; num++; &#125; &#125; if(num === 0)&#123; alert(\"密码至少要有一位字母\"); return false; &#125; return true; &#125; onblur:失去焦点时 &lt;!DOCTYPE html> &lt;html lang=\"zh\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;style> [id$='s']&#123; color: red; &#125; &lt;/style> &lt;script> function checkForm() &#123; if(checkUsername() &amp; checkPassword())&#123; return true; &#125; return false; &#125; function checkUsername() &#123; let username = document.querySelector(\"[name='username']\").value; var us = document.querySelector(\"#us\"); us.innerText = \"\" if(username.trim() === \"\")&#123; // alert(\"用户名不能为空\"); us.innerText = \"用户名不能为空\" return false; &#125; if(username.trim().length &lt; 3)&#123; alert(\"用户名长度不能小于3\"); return false; &#125; return true; &#125; function checkPassword() &#123; let password = document.querySelector(\"[name='password']\").value; var ps = document.querySelector(\"#ps\"); ps.innerText = \"\"; if(password.trim() === \"\")&#123; ps.innerText = \"密码不能为空\"; return false; &#125; if (password.trim().length &lt; 7)&#123; ps.innerText = \"密码不能小于七位\"; return false; &#125; let num = 0; for (let i = 'a' ; i &lt;'z' ; i++)&#123; if (password.trim().indexOf(i) >= 0)&#123; num++; &#125; &#125; for (let i = 'A' ; i &lt; 'Z' ; i ++)&#123; if (password.trim().indexOf(i) >= 0)&#123; num++; &#125; &#125; if(num === 0)&#123; ps.innerText = \"至少有一位字母\"; return false; &#125; return true; &#125; &lt;/script> &lt;/head> &lt;body> &lt;form action=\"login\" method=\"get\" onsubmit=\"return checkForm()\"> &lt;table> &lt;tr> &lt;td>用户名:&lt;/td> &lt;td>&lt;input type=\"text\" name=\"username\" onblur=\"checkUsername()\">&lt;/td> &lt;td>&lt;span id=\"us\">&lt;/span>&lt;/td> &lt;/tr> &lt;tr> &lt;td>密码:&lt;/td> &lt;td>&lt;input type=\"password\" name=\"password\" onblur=\"checkPassword()\">&lt;/td> &lt;td>&lt;span id=\"ps\">&lt;/span>&lt;/td> &lt;/tr> &lt;tr> &lt;td colspan=\"3\"> &lt;input type=\"submit\" value=\"登录\"> &lt;/td> &lt;/tr> &lt;/table> &lt;/form> &lt;/body> &lt;/html> BOM BOM:浏览器对象模型，是用于操作浏览器窗口的对象模型，提供了一套对象，属性和方法，让js调用 window:BOM的核心对象，表示一个浏览器实例，全局的变量和参数都可以认为是window的成员 常用方法 alert(‘字符串’):表示一个警告对话框 prompt(“提示”,”默认值”):显示可提示用户输入的对话框，返回用户输入的值 confirm(“提示文字”):显示一个确认对话框，选择”确定”返回true，否则返回false var b = confirm(\"是否删除?\") document.write(b); open(url,windowName,”窗口属性”):打开一个新的窗口,该方法返回值表示打开窗口对象的引用 windowName:新窗口的名字，先判断叫这个名字的窗口是否已经创建，如果已经创建，则显示，没有就创建新的 document.querySelector(&quot;[value&#x3D;&#39;open&#39;]&quot;).addEventListener(&#39;click&#39;,function()&#123; open(&#39;表单检验.html&#39;,&quot;newWin&quot;,&quot;width&#x3D;300px,left&#x3D;100,top&#x3D;200&quot;); &#125;) close():关闭窗口 location对象:该对象包含有关当前URL的信息 href:其值为地址栏中的地址，改变这个属性可以实现切换网页的效果 location.href &#x3D; &quot;login.html&quot;; location &#x3D; &quot;login.html&quot;; reload():刷新网页 history对象:保存用户上网的历史记录 方法 back():后退一页 forward():前进一页 go(value):可以在历史记录中任意跳转 DOM DOM:文档对象模型(html、xml:可扩展标记语言) HTML文档解析 当浏览器加载HTML文档的时候，会把该网页解析为一颗DOM树，最顶层的对象:document 解析过程中会把网页中的所有内容解析为节点(Node) 文档本身就是一个文档对象 所有html元素都是元素节点(&lt;p&gt;) 所有html属性都是属性节点 &lt;p class = \"class1\"> &lt;/p> 插入到html元素中的文本是文本节点 &lt;p> tom&lt;!--文本节点--> &lt;/p> 元素对象：代表一个HTML元素(html标签) 元素对象的子节点可以是:元素节点、文本、注释 节点的类型:12种 元素节点：html元素，nodeType:1 属性节点：html元素的属性，nodeType:2 文本节点：html元素中文本，nodeType:3 注释节点：html中的注释，nodeType:8 文档对象节点：document对象，nodeType:9 文档片段节点：表示一个没有父节点的文档片段，nodeType:11 节点属性 parentNode:获取当前节点的父节点(Node类型) parentElement:获取当前节点的父元素(HTMLElement类型) children：获取当前元素的所有子元素 childNodes:获取当前元素的所有子节点 previousSibling:获取的当前节点的前一个同级节点 previousElementSibling:获取的当前节点的前一个同级元素 nextElementSibling:获取的当前节点的后一个同级元素 textContent：获取当前节点的文本内容 innerHTML:获取当前节点的所有节点内容 节点操作 remove()：删除当前元素或节点 创建节点 document.createElement(\"标签名\") 追加子节点 节点对象.appendChild(子节点) 省市连级&lt;!DOCTYPE html> &lt;html lang=\"zh\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;script> function getCities(dic)&#123; var cityObj = &#123; &#125;; cityObj[\"辽宁\"] = [\"沈阳\",\"大连\",\"鞍山\",\"阜新\",\"本溪\",\"朝阳\",\"盘锦\",\"锦州\",\"葫芦岛\"]; cityObj[\"吉林\"] = [\"吉林\",\"长春\"]; cityObj[\"黑龙江\"] = [\"哈尔滨\",\"齐齐哈尔\"]; cityObj[\"河北\"] = [\"石家庄\"] if (dic == 0)&#123; let cityDom = document.querySelector(\"#city\"); cityDom.length = 1; for (let i = 0; i &lt; cityObj.辽宁.length; i++) &#123; let c1 = new Option(cityObj.辽宁[i],i); cityDom.options.add(c1); &#125; &#125; if (dic == 1)&#123; let cityDom = document.querySelector(\"#city\"); cityDom.length = 1; for (let i = 0; i &lt; cityObj.吉林.length; i++) &#123; let c1 = new Option(cityObj.吉林[i],i); cityDom.options.add(c1); &#125; &#125; if(dic == 2)&#123; let cityDom = document.querySelector(\"#city\"); cityDom.length = 1; for (let i = 0; i &lt; cityObj.黑龙江.length; i++) &#123; let c1 = new Option(cityObj.黑龙江[i],i); cityDom.options.add(c1); &#125; &#125; if (dic == 3)&#123; let cityDom = document.querySelector(\"#city\"); cityDom.length = 1; for (let i = 0; i &lt; cityObj.河北.length; i++) &#123; let c1 = new Option(cityObj.河北[i],i); cityDom.options.add(c1); &#125; &#125; &#125; &lt;/script> &lt;/head> &lt;body> 省份: &lt;select onchange=\"getCities(this.value)\"> &lt;option>请选择&lt;/option> &lt;option value=\"0\">辽宁&lt;/option> &lt;option value=\"1\">吉林&lt;/option> &lt;option value=\"2\">黑龙江&lt;/option> &lt;option value=\"3\">河北&lt;/option> &lt;/select> 城市: &lt;select id=\"city\"> &lt;option>请选择&lt;/option> &lt;/select> &lt;/body> &lt;/html> 通过JS修改元素的样式 通过元素的style属性修改 css样式中的-去掉 document.querySelector(&quot;p&quot;).style.color &#x3D; &#39;red&#39;; document.querySelector(&quot;p&quot;).style.fontSize &#x3D; &quot;20px&quot;; 通过元素的className属性设置类样式 &lt;style> .class1&#123; color: blue; font-size: 30px; font-weight: bold; border: 1px solid ; &#125; &lt;/style> document.querySelector(\"p\").className = 'class1'; 通过元素的classList属性设置样式 &lt;style> .class1&#123; color: blue; font-size: 30px; font-weight: bold; border: 1px solid ; &#125; .class2&#123; font-style: italic; &#125; &lt;/style> document.querySelector(\"p\").classList.add(\"class1\"); document.querySelector(\"p\").classList.add(\"class2\"); document.querySelector(\"p\").classList.remove(\"class2\");//移除样式 Web存储 定义:web存储是浏览器提供的一种在客户端存储键值对数据的机制，它允许网站存储数据，即使在浏览器关闭和重新打开后，也能访问，web存储有两种方式 localStorage sessionStorage localStorage 持久性存储：即使在浏览器关闭后，也不丢失 作业域：localStorage的数据对于同一浏览器的同一源(相同协议、域名和端口相同)是可以访问的 存储限制:通常限制为每个源5MB 方法 setItem(key,value):key是字符串,value也是字符串 getItem(key):根据key得到值 removeItem(key):根据key移除键值对 clear():清除所有 sessionStorage 会话级别存储：数据存储在sessionStorage中，只在当前浏览器标签或窗口的生命周期内持续，关闭标签或窗口后，数据将被清除 作用域：存储限制和方法都与localStorage相同 JSON 定义：javaScript对象表示法，是一种用于储存和传输数据的格式，特别是在web开发中，现在已经是许多编程语言之间交换数据的通用标准。 组成 键值对的集合：通过大括号&#123;&#125;表示 值的有序列表：通过中括号[]表示 JSON的解析与序列化 序列化JS对象：通过使用JSON.stringify():可以将JS对象转换为JSON格式的字符串 解析JSON字符串:通过JSON.parse()方法，将JSON格式字符串转换为JS对象 var stu &#x3D; JSON.parse(stustr);&#x2F;&#x2F;返回JS对象","categories":[{"name":"H5&CSS3","slug":"H5-CSS3","permalink":"http://yiyecreb.top/categories/H5-CSS3/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"企业常见笔试面试题","slug":"企业常见笔试面试题","date":"2023-08-18T01:14:51.092Z","updated":"2023-08-28T02:33:04.272Z","comments":true,"path":"2023/08/18/企业常见笔试面试题/","link":"","permalink":"http://yiyecreb.top/2023/08/18/%E4%BC%81%E4%B8%9A%E5%B8%B8%E8%A7%81%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"企业常见笔试面试题抽象类和接口的异同相似点： 都是用于实现多态性：抽象类和接口都可以用于定义方法的规范，从而实现多态性，让不同的类根据需要提供自己的实现 都不能被实例化 都可以包含方法的声明(抽象的方法) 不同的： 方法的实现不同 抽象类可以包含抽象方法和具体方法 接口只能包含抽象方法(在java8之后也可以包含默认方法和静态方法) 继承与实现 类可以继承一个抽象类，但只能继承一个类 类可以实现多个接口，从而实现多重继承 字段 抽象类可以包含字段(成员变量)，可以是普通字段或静态字段 接口中可以包含常量 构造方法 抽象类可以有构造方法，可以被子类调用 接口不能有构造方法 用途： 抽象类通常用于表示一种通用的概念，可以包含一些通用的属性和方法，子类可以继承并拓展 接口用于定义一组相关的方法规范，让不同的类实现相同的方法规范，以实现一种约定的行为 数据库连接池数据库连接池是一种数据库连接资源管理工具，常见的Java应用程序中，通常会频繁地打开和关闭数据库连接，由于建立连接，需要耗费较多的时间和资源，所以，频繁地打开和关闭连接可能会降低系统性能 数据库连接池能够在初始化时创建一定数量的连接，当应用程序需要连接访问数据库时候，可以从连接池中获取已经创建的连接，使用后再将连接归还给连接池，这样可以提高资源利用率，降低系统开销 常见数据库连接池 C3P0 HikariCP Apache DBCP 静态多态和动态多态 静态多态是在编译时实现的多态性，主要体现在方法重载，当在同一个类中定义了多个相同名称但参数列表不同的方法时，就发生了方法重载，编译器在编译时根据方法名称和参数类型来决定调用哪个版本的方法 动态多态是在运行时实现的多态性，主要体现在方法重写上，当子类继承父类并重写父类的方法时，Java虚拟机会在运行时决定调用哪个版本的方法，即使子类对象是通过父类引用访问的，也会调用子类的方法，而不是父类的方法 Error和Exception有什么区别在java中，Error和Exception都是Throwable类的子类，代表了程序中可能出现的不同类型的问题 Error表示严重的系统级错误，不应由程序处理 Exception表示可能由程序处理的错误或异常情况 Error通常意味着不可恢复的情况，而Exception则可能是可恢复的，取决于异常的类型和情况 在编写程序的时候，应关注Exception的处理，不必担心Error","categories":[{"name":"Java","slug":"Java","permalink":"http://yiyecreb.top/categories/Java/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Html&CSS","slug":"HTML&CSS","date":"2023-08-16T16:00:00.000Z","updated":"2023-08-22T02:32:34.841Z","comments":true,"path":"2023/08/17/HTML&CSS/","link":"","permalink":"http://yiyecreb.top/2023/08/17/HTML&CSS/","excerpt":"","text":"HTML&amp;CSSHTML 定义：超文本标记语言 用途：编写网页 最新版本：HTML5 编写工具：任何文本编辑器都可以 html文档结构 &lt;!DOCTYPE html>&lt;!--文档声明:表示该文档类型为html，并且版本号为5--> &lt;html lang=\"zh-CN\">&lt;!--根标签，表示文档的开始，lang表示语言，en表示英文，中文:zh-CN--> &lt;head>&lt;!--头部标签，这些内容大多数不在网页中显示，对文档的一个说明--> &lt;meta charset=\"UTF-8\">&lt;!--指出当前文件的编码类型，使用UTF-8--> &lt;title>day1&lt;/title>&lt;!--标题，会显示在网页--> &lt;/head> &lt;body> &lt;h1>Hello World!&lt;/h1> &lt;/body> &lt;/html> html语言不区分大小写 常用标签 标题标签:h1–h6，依次减小 &lt;h1>这是一级标题标签&lt;/h1> &lt;h2>这是二级标题标签&lt;/h2> &lt;h3>这是三级标题标签&lt;/h3> &lt;h4>这是四级标题标签&lt;/h4> &lt;h5>这是五级标题标签&lt;/h5> &lt;h6>这是六级标题标签&lt;/h6> 段落标签:p &lt;p>&lt;/p> 换行标签:br &lt;br> 水平线:hr &lt;hr size=\"\" > 对齐属性:align,值:left左对齐，center居中，right右对齐 strong:逻辑字体标签，表示强调，有的浏览器会解释为加粗效果 em:逻辑字体标签，表示一般强调，有的浏览器会解释为斜体效果 img:图片标签 &lt;img src=\"图片的路径\" title=\"悬停显示的文字\" width=\"宽度(像素)\" height=\"高度\" align=\"图片旁边文字与图片对齐的方式:top顶端对齐,middle:中间对齐,bottom:底端对齐\"> 路径 .&#x2F;:当前目录 ..&#x2F;上一级目录 超链接：a &lt;a href=\"网页的url#锚机点名\" name=\"定义锚机垫的名称，废弃属性，现在使用id\">&lt;/a> target:目标，在哪里打开网页 _self:默认值，在当前网页中显示链接URL _blank:在一个新页面中显示连接URL 字体标签:font(html5中被废弃) color:颜色 size:大小，1–7,1最小 face：字体类型，如：宋体，隶书(操作系统支持) 字符实体：在html语言中，有一些字符，如: “&lt;”或“&gt;”等，不能直接使用，在需要使用的时候，通过字符实体来转换 一个字符实体由三部分组成 一个&amp;符号 一个实体名或实体号 一个分号 常用实体 空格：&amp;nbsp; 小于号:&amp;lt; 大于号:&amp;gt; 版权符号:&amp;copy; 双引号:&amp;quot; 注释:&lt;!----&gt; 有序序列:ol type:1,a,A,i,I start:表示开始位号 无序列表：ul type:disc(实心圆点),circle(空心圆点),square(实心方形点) 自定义列表：dl &lt;dl> &lt;dt>水果&lt;/dt> &lt;dd>西瓜&lt;/dd> &lt;dd>苹果&lt;/dd> &lt;dd>香蕉&lt;/dd> &lt;dt>蔬菜&lt;/dt> &lt;dd>黄瓜&lt;/dd> &lt;dd>卷心菜&lt;/dd> &lt;dd>西红柿&lt;/dd> &lt;dd>娃娃菜&lt;/dd> &lt;/dl> dt:定义列表项(定义标题) dd:对定义项的解释(内容) div:独占一行 span:空标签，没有先设置的任何样式 表格 table:表格 thead:表格头 tbody:表格主体 tfoot:表格尾 tr:行 th:标题单元格(加粗，居中) td:普通单元格(不加粗，靠左) caption:表格标题 align:对齐 写到table标签中，整个表格对齐方式 写到tr中，表格中所有单元格的内容对齐 写到td中，当前单元格内容对齐 其他属性 border:边框宽度 width:表格宽度 height:表格高度 单元格合并 colspan：列合并 rowspan：行合并 表单 作用：收集用户的信息，提交给服务器，是进行程序交互的一个主要方式 form是一个包含表单元素的取余 常用属性 action：表示把当前表单数据提交给谁(应用)来进行处理 method：表示提交数据的方式 常用：get和post(默认是get) 表单元素 文本框 &lt;input type=\"text\" name=\"username\" placeholder=\"请输入用户名\" value=\"默认值\">&lt;button>&lt;/button> type:表单的类型，text：文本框 name:表单元素名称(访问标识) size:宽度 placeholder:占位符(提示文字) value:初始值 密码框 &lt;input type=\"password\" placeholder=\"请输入密码\"> 单选按钮 &lt;input name=\"gender\" type=\"radio\">男 &lt;input name=\"gender\" type=\"radio\">女 注意:单选按钮的name的值用来分组，名称相同的是一组，一组中只有一个能被选中 checked:默认被选中 label:不是表单元素，往往与某个表单元素绑定，扩大操作范围 用途： 表单元素和提示文字放在表单标签中 &lt;label>&lt;input name=\"gender\" type=\"radio\" checked >男&lt;/label> &lt;label>&lt;input name=\"gender\" type=\"radio\">女&lt;/label> 表单元素添加id属性，label通过for属性设置绑定元素的id &lt;label for=\"txt\">用户名&lt;/label>&lt;input id=\"txt\" type=\"text\" name=\"username\" placeholder=\"请输入用户名\">&lt;button>&lt;/button> 复选框 爱好:&lt;input type=\"checkbox\" name=\"hobby\">学java &lt;input type=\"checkbox\" name=\"hobby\" checked>玩游戏 &lt;input type=\"checkbox\" name=\"hobby\">打篮球 选择框select 省份:&lt;select name=\"area\" id=\"\" size=\"10\" multiple> &lt;option>请选择&lt;/option> &lt;option>浑南区&lt;/option> &lt;option>大东区&lt;/option> &lt;option>铁西区&lt;/option> &lt;option>苏家屯区&lt;/option> &lt;/select> size:同时显示列项的数目 multiple:可以选中多项 selected:写到option中，表示被选中 value:写到option中，表示当前option中的value 文本域 &lt;textarea>&lt;/textarea> rows:显示行数 cols:显示列数 按钮 &lt;input type=\"submit | reset | button | image\" value =\"按钮的文字\"> submit:提交按钮，作用:把表单元素的内容提交给action对应的程序进行处理 reset:重置按钮 button:普通按钮，通过js实现功能 隐藏域 隐藏起来的表单元素 &lt;input type=\"hidden\" name = \"id\" value=\"100\"> 文件域 &lt;input type=\"file\"> 作用:用来选择文件，并上传文件 字段集 不是表单元素 &lt;fieldset>&lt;/fieldset> 图例 &lt;legend>&lt;/legend> readonly属性:只读，数据会被提交给服务器 disable:不可用的，值不会传给服务器 h5中对input标签进行了拓展 search:产生一个搜索表单元素，输入文字后会出现清除按钮 email:限制用户必须输入一个合法的email，否则无法提交 number:限制用户必须输入数字 max min range:产生一个滑动条，来设置一个值 color:产生一个颜色选择表单元素 date:选择日期 time:选择时间 month:选择月份 week:选择星期 h5中增加的属性 required:输出框内容不能为空，否则无法提交 novalidate:用户提交表单时，取消整个表单验证 iframe创建包含另外一个文档的内嵌框架，可以将另一个html页面嵌入到当前页面中 &lt;p> &lt;a href=\"./book.html\" target=\"iframe1\">内容页1&lt;/a> &lt;a href=\"./FormDemo2.html\" target=\"iframe1\">内容页2&lt;/a> &lt;a href=\"./shop.html\" target=\"iframe1\">内容页3&lt;/a> &lt;iframe src=\"./updateuser.html\" name=\"iframe1\" width=\"100%\" height=\"100%\">&lt;/iframe> &lt;/p> CSS 概述 定义：层叠样式表 作用： 内容与样式分离 极大地提高工作效率 语法规则 选择器&#123; 属性 &#125; 按照样式表位置分为三类 行内样式：写在html标签中，仅对html标签有效 内嵌样式：写在当前页面的head标签的style标签中 外部样式表：写在当前文件的外部文件中，后缀为css的文件 &lt;link rel=\"stylesheet\" href=\"style.css\"> rel必须为stylesheet，不能省略 type:可以省略 href:css样式的路径，必须写 &lt;style> @import url(\"css/style.css\") &lt;/style> 注意:三种样式表的优先级:行内样式&gt;内嵌样式&gt;外部样式 基本选择器 html标签选择器:选择器的名称为html标签名 类选择器:(使用最多的选择器) 定义:.类名 引用:class&#x3D;”类名” id选择器:对指定id元素设置样式 定义:#id名 引用:id&#x3D;”id名” 通用选择器L*,表示所有元素 复合选择器 后代选择器: 祖先选择器 后代选择器&#123; &#125; 交集选择器: p.div&#123; /*第一个必须是html标签，第二个必须是类/ID选择器，选择器之间不能有空格*/ &#125; 并集选择器: p,class1,class2&#123; &#125; 样式的层叠规则 并列的定义，后定义的优先级高 不同等级的定义，最接近指定元素的样式优先极高 行内样式&gt;内嵌样式&gt;外部样式 同一等级的定义:一个含糊的选择器的优先级比一个更有针对性的选择器的优先级低 行内选择器的优先级最高 交集选择器 id选择器 类选择器 html标签选择器 通用选择器 浏览器对标签预定义的样式 继承的样式优先级最低 CSS字体样式 字体样式 font-size:文字大小 color:文字颜色 font-family:字体类型 font-style:字体样式(italic斜体) font-weight:字体粗细(粗体:bold) 数值:100-900,400:normal,700:bold text-decoration:文本装饰 underline|none font:在一个声明中设置所有的字体属性，属性顺序:风格,字体粗细,字体大小,字体类型,字体颜色; 文本属性 text-align:文本水平对齐方式 left right center justify:两端对齐 text-indent:首行文本缩进 line-height:设置元素内文本行之间的垂直间距 line-height:24px line-height:1.5;行高是字体大小的1.5倍 line-height:150%;行高是字体大小的150% line-height:normal;使用浏览器默认的行高 伪类 定义：基于的是当前元素的状态，由于状态是动态变化的，所以一个元素达到一个特定状态时，得到一个伪类样式，，失去状态的时候就失去了这个样式 :hover：鼠标悬停 :nth-child(n):选择父元素中第N个子元素，n从1开始 背景颜色 background-color背景颜色 列表样式 ul&#123; list-style:none; &#125; 图片 img&#123; opacity: .5;/*透明度*/ width: 300px; &#125; 盒子模型 每个html元素都可以看作一个盒子，这个盒子由四部分组成 width，height:宽高 padding:内边距 margin:外边距 border:边框 元素的分类 类别 块级元素 行内元素 行内块元素 块级元素 例如：div、p、h1—h6、ul、li 总是从新行开始（独占一行） 高度、宽度、行高(line-height)、外边距以及内边距都是可以控制的 宽度默认是容器的100% 可以容纳任何元素 行内元素 例如：a、strong、span 和相邻行内元素在一行上 高度和宽度无效，padding、border、margin有效 行内元素只能容纳文本或其他行内元素（a特殊） 行内块元素 例如：img、td 可以跟其他行内块元素在一行上 高度和宽度有效 没有宽度的时候，内容撑开宽度 类型转换 display：类型转换 作用： 控制元素在块级与其他类型间转换 控制元素的显示和隐藏 值： block:显示为块级元素 inline-block：显示为行内块元素 inline：显示为行内元素 none：隐藏元素 背景图像 background-image:url(图片路径) background-repeat: no-repeat|repeat(默认)|repeat-x|repeat-y 定位 标准文档流 概念：是指页面元素从上向下，从左到右，一个挨着一个的布局方式 定位模式 static：静态定位,自动定位（默认方式，按照标准文档流定位） relative：相对定位，相对于当前元素在文档流的位置进行定位 相对定位后，可以通过边偏移量属性改变元素的位置，但是它在文档流中的位置仍然保留 边偏移量是相对于该元素在标准流中的位置变化 fixed：固定定位，相对于浏览器窗口进行定位 特点：完全脱离标准流，不占用任何位置，不随着滚动条滚动 absolute：绝对定位，相对于其上一个已经定位的父元素进行定位 特点： 它完全脱离标准流，完全不占位 父级没有定位：若所有父元素都没有定位，以浏览器为准定位 父元素定位可以是static定位之外的任意一种 父相子绝 叠放次序 当多个元素同时设置了定位时，定位元素之间可能会发生重叠 使用z-index来控制叠放次序 z-index的默认值是0，取值越大，定位元素在层叠元素中越居上，如果取值相同，则根据书写顺序，后来居上 只有相对定位、绝对定位和固定定位有此属性 元素的显示和隐藏 display:none（隐藏元素），显示：block|inline|inline-block 特点：隐藏之后，不在保留位置 visibility：设置是否显示元素 visible：可见的 hidden：隐藏 特点：隐藏之后，继续保留原有位置 overflow：溢出 作用：设置当前元素中子元素的内容超过其指定高度和宽度的时候，如何管理内容（子元素） 值： visible：不裁剪内容，也不添加滚动条 hidden：隐藏超出部分 scroll：不论是否超出，都显示滚动条 auto:超过显示滚动条，不超出不显示 弹性布局 定义：是一种CSS布局模式，它允许容器中的子元素在不同屏幕尺寸和设备上自动调整大小和位置以适应可用空间 display：flex：设置当前元素为弹性盒子 flex-direction：设置弹性容器的主轴方向 row:水平排列 row-reverse:水平反向排列 column：垂直排列 column-reverse:垂直反向排列 justify-content：设置子元素在主轴上的对齐方式 flex-start：主轴开始位置 flex-end：主轴结束位置 center：主轴居中位置 space-around：空间环绕每一个子元素 space-between：空间在子元素之间存在 align-items：设置在交叉轴上对齐子元素 flex-start：交叉轴开始位置 flex-end：交叉轴结束位置 center：交叉轴居中位置 baseline：子元素根据其基线对齐 stretch:默认值，子元素会被拉伸以填充容器的高度或宽度（取决于主轴的方向），如果子项设置了高度或宽度，则拉伸无效","categories":[{"name":"H5&CSS3","slug":"H5-CSS3","permalink":"http://yiyecreb.top/categories/H5-CSS3/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"JDBC","slug":"JDBC","date":"2023-08-10T16:00:00.000Z","updated":"2023-08-14T06:50:57.884Z","comments":true,"path":"2023/08/11/JDBC/","link":"","permalink":"http://yiyecreb.top/2023/08/11/JDBC/","excerpt":"","text":"JDBC概述 JDBC：java数据库连接技术 特点： 是一种用于执行Sql语句的JavaAPI 可以为多种关系型数据库提供统一接口 它是由一组Java语言编写的类和接口组成 是java中访问数据库的标准规范 驱动 Java提供访问数据库的一个规范，生产厂商提供规范的实现类称为驱动 每个数据库厂商都需要提供自己的驱动，用来连接自己公司的数据库 JDBC操作过程注册驱动 在项目的依赖中添加驱动jar包 在程序中注册驱动 Class.forName(\"驱动类完全限定名\"); Class.forName(\"com.mysql.cj.jdbc.Driver\");//mysql8的驱动 Class.forName(\"com.mysql.jdbc.Driver\");//mysql8以下的驱动 获得到数据库的连接 jdbc规范规定url格式由三部分组成，每部分中间用冒号分隔 第一部分：jdbc，这是规定的 第二部分：数据库名称 第三部分：由数据库厂商规定，需要按照厂商要求编写 jdbc:mysql://localhost:3306/mall?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai 得到连接 Class.forName(\"com.mysql.cj.jdbc.Driver\"); Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai\", \"root\", \"1\"); connection.close(); 获得执行sql语句的命令对象 Statement statement = connection.createStatement(); 执行sql int n = statement.executeUpdate(sql);//n表示影响数据库的行数 释放资源 statement.close(); connection.close(); 处理结果集 ResultSet executeQuery(String sql)：用来执行查询语句，得到结果集 next()：指针向下移动一个位置，如果有下一个位置返回true，没有返回false getXXX(int 列号)：获取结果集当前行中列号对应的值，并转换为XXX类型(列号从1开始) getXXX(String 列名|列别名)：获取结果集当前行，当前列名或列别名对应的值，并转为XXX的类型 PreparedStatement 该对象具有预先处理的功能，其执行速度要快于Statement，是接口，继承于Statement 能够避免sql注入式攻击 该接口提供了一套方法用于设置发送给数据库的sql语句占位符 setXXX():XXX代表占位符的数据类型 PreparedStatement p = connection.prepareStatement(sql);//从连接对象中调用该方法，放回预处理对象 ResultSet rs = p.executeQuery();//不要再写入sql语句 事务管理 事务：一组SQL语句组成，把这些Sql语句看作一个整体处理，要么全部执行成功，要么全部执行不成功 步骤 取消自动提交 connection.setAutoCommit(false);//默认是true 提交事务 connection.commit(); 回滚事务 connection.rollback(); 项目 Lombok 是一个java库，它会自动插入编辑器和构建工具中，Lombok提供了一组有用的注释用来消除java类中大量的样板代码，仅五个字符(@Data)就可以替代百行代码从而产生干净整洁易于维护的java类 使用 在开发工具中安装Lombok插件(Idea中集成) 在项目中引入lombok.jar包 使用lombok注解 jdbcTemplate 是Spring Framework提供的一个JDBC技术的简化封装工具，它可以帮助我们更方便地进项数据库操作。","categories":[{"name":"Java","slug":"Java","permalink":"http://yiyecreb.top/categories/Java/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Maven","slug":"Maven","date":"2023-08-10T16:00:00.000Z","updated":"2023-09-20T08:07:10.185Z","comments":true,"path":"2023/08/11/Maven/","link":"","permalink":"http://yiyecreb.top/2023/08/11/Maven/","excerpt":"","text":"Maven概述 Apache Maven是一个项目管理及自动构建工具。 项目管理：编译、测试、运行、打包(jar,war)、部署 依赖管理 下载 http:&#x2F;&#x2F;maven.apache.org 安装、配置 直接解压即可 配置环境变量 M2_HOME&#x3D;&gt;maven的解压目录 修改 path&#x3D;&gt;添加%M2_HOME%\\bin 测试：mvn-v maven仓库 本地仓库：本地的一个文件夹 中央仓库：世界唯一的，由Maven社区维护的(网站) https://mvnrepository.com/ 远程仓库：是位于web服务器上的一个私有仓库，一般由自己公司创建和维护 镜像仓库：是中央仓库的镜像(副本)，目的是加快依赖jar包的下载 修改Maven配置 修改：maven的安装目录下的config&#x2F;settings.xml &#x2F;&#x2F;修改本地仓库的位置 &lt;localRepository&gt;D:\\repo&lt;&#x2F;localRepository&gt; 配置阿里云的镜像 &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;&#x2F;id&gt; &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&lt;&#x2F;url&gt; &lt;&#x2F;mirror&gt; &lt;&#x2F;mirrors&gt; 使用 maven目录结构 src：源程序目录 main:源程序目录 java:程序 resources:资源文件 webapp:web项目(不是web项目没有) test:测试代码 target：项目生成的结果 创建Maven项目 maven project向导 配置三个坐标(定位唯一的jar包) groupId(组ID)：组织或公司的域名 artifactId：组件名(项目名) version：版本号 配置打包方式 jar(默认打包方式，控制台项目或Window项目) war(web项目) pom(maven的管理项目) pox.xml &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>com.neu&lt;/groupId> &lt;artifactId>mavendemo&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;packaging>war&lt;/packaging> &lt;build> &lt;plugins> &lt;!-- 资源文件拷贝插件 --> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-resources-plugin&lt;/artifactId> &lt;version>2.7&lt;/version> &lt;configuration> &lt;encoding>UTF-8&lt;/encoding> &lt;/configuration> &lt;/plugin> &lt;!-- java编译插件 --> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>3.2&lt;/version> &lt;configuration> &lt;source>1.8&lt;/source> &lt;target>1.8&lt;/target> &lt;encoding>UTF-8&lt;/encoding> &lt;/configuration> &lt;/plugin> &lt;plugin> &lt;groupId>org.apache.tomcat.maven&lt;/groupId> &lt;artifactId>tomcat7-maven-plugin&lt;/artifactId> &lt;version>2.2&lt;/version> &lt;configuration> &lt;path>/&lt;/path> &lt;port>8089&lt;/port> &lt;/configuration> &lt;/plugin> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-war-plugin&lt;/artifactId> &lt;version>2.1.1&lt;/version> &lt;configuration> &lt;webResources> &lt;resource> &lt;excludes> &lt;exclude>**/WEB-INF/web.xml&lt;/exclude> &lt;/excludes> &lt;directory>src/main/webapp&lt;/directory> &lt;/resource> &lt;/webResources> &lt;failOnMissingWebXml>false&lt;/failOnMissingWebXml> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;!-- 依赖 --> &lt;dependencies> &lt;!-- 单元测试 --> &lt;!-- https://mvnrepository.com/artifact/junit/junit --> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.12&lt;/version> &lt;/dependency> &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --> &lt;dependency> &lt;groupId>javax.servlet&lt;/groupId> &lt;artifactId>javax.servlet-api&lt;/artifactId> &lt;version>3.1.0&lt;/version> &lt;scope>provided&lt;/scope> &lt;/dependency> &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/jsp-api --> &lt;!-- &lt;dependency> &lt;groupId>javax.servlet.jsp&lt;/groupId> &lt;artifactId>jsp-api&lt;/artifactId> &lt;version>2.2&lt;/version> &lt;scope>provided&lt;/scope> &lt;/dependency> --> &lt;/dependencies> &lt;/project>","categories":[{"name":"框架","slug":"框架","permalink":"http://yiyecreb.top/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Java","slug":"JavaSE","date":"2023-08-10T16:00:00.000Z","updated":"2023-08-17T01:34:33.920Z","comments":true,"path":"2023/08/11/JavaSE/","link":"","permalink":"http://yiyecreb.top/2023/08/11/JavaSE/","excerpt":"","text":"Java概述 java特点:跨平台性，一次编译，到处运行 Java的加载与执行： 编程语言： 机器语言：使用机器指令编程 汇编语言：通过大量英文单词来代表计算机指令 高级语言：C、Python、Java、C++、php、C#、JS 编译：把其他语言编程的程序转换为机器指令 虚拟机：虚拟的操作系统,模仿真实的计算机 语言版本 1990年 Sun公司开始研发，创始人：詹姆斯-高斯林 2009年 Oracle收购 2014年 Java8 2022年10月 Java19 版本 JavaSE：java标准版，编写控制台，Windows程序 JavaEE：java企业版，web应用(淘宝、京东) JavaME：java微缩版，用于嵌入式设备 环境搭建： JDK：Java开发工具包 bin：存放了很多命令 java.exe:运行Java程序 javac.exe:编译源程序，生成字节码文件 javadoc.exe:生成文档 JRE：Java运行时的环境 环境变量的配置 JAVA_HOME:指出jdk的安装目录 path：查找命令而设立的，%JAVA_HOME%\\bin 集成开发环境 Eclipse IntelliJ Idea 注释 作用： 对已有代码添加注释，是对代码的解释说明，便于阅读和理解 暂时不想执行的代码先注释掉，需要的时候再打开注释 生成文档 注释的种类 单行注释：以两个正斜线//开头，只是对当前行内容注释掉，对下一行不起作用，快捷键Ctrl + / 多行注释：注释多行代码，以/*开头，以*/结尾，多行注释不能嵌套，快捷键Ctrl+Shift+/ 文档注释：/**文档注释内容*/，使用java文档工具(JavaDoc)，可以提取出这些注释内容，生成帮助文件或显示在代码提示中 在Idea中，工具 &#x3D;&gt; 生成JavaDoc 默认使用gbk编码，如果想生成UTF-8编码的文档，在生成界面中修改：命令行实参:-encoding utf-8 变量和运算符变量 变量:代表着内存中的一段空间，用来存储可能变化的数据 变量的声明 变量类型 变量名 [&#x3D; 变量的初始值]; int n; n = 5000; int n = 5000;//声明的同时进行初始化 注意: 局部变量(方法中定义的变量)，没有默认值 变量必须先声明再使用 变量的作用： 输出变量的值 使用变量参与运算 变量的作用域(在哪个范围内可以使用) 从定义处开始到当前定义的代码块结束的大括号为止 在一个作用域中不能有重名的变量名 标识符： 定义：Java中的类、包、方法、变量等的名称称为标识符。 命名规则： 必须以字母、下划线(_)或美元符号($)开头 其余的字符可以是字母、下划线、美元符号或数字(长度不限) 标识符中不能有空格 不能使用Java的关键字和保留字 关键字：事先定义好的对编译有特殊意义的单词 class,int 保留字：Java语法中暂时没有使用到该单词，但是保留起来，以后可能会使用 goto 数据类型 Java中数据类型分为两大类 基本数据类型：int等 引用类型：class 基本数据类型： 整数类型： byte：字节，1byte &#x3D; 8bit、从-128到127 short：短整数，2个字节，16bit，-32768到32767 short s1 = Short.MAX_VALUE; System.out.println(s1); short s1 = Short.MIN_VALUE; System.out.println(s2); int：整数型，4个字节，32bit,正负21亿多 long：长整数，8个字节，64bit，共19十进制位，后缀：L 进制：一种表示数字的方法，也称为基数或基数系统。常用：二进制、八进制、十进制、十六进制 二进制以二为基数，使用0和1来表示数值，10表示2，以0b为前缀 八进制以八为基数，使用0到7来表示数值，10表示8，以0为前缀 十六进制以十六为基数，使用0到9,A到F来表示数值，10表示16，以0x或0X为前缀 进制转换 其他进制字符串转换10进制整数 Integer.parseInt(10,进制数) 例如: Integer.parseInt(10,2) //把二进制10转换为十进制整数 把十进制的整数转换为其他进制的字符串 String binaryString = Integer.toBinaryString(10);//转2 System.out.println(binaryString); String octalString =Integer.toOctalString(10);//转8 System.out.println(octalString); String hexString =Integer.toHexString(10);//转16 System.out.println(hexString); 浮点数：近似小数，可以表示很大范围的数值，但精度(有效位数)有限 float:单精度浮点数，4字节存储，32bit，有效位数:6~7位，后缀L double:双精度浮点数，8字节，64bit，有效位数约为15位，后缀D float f1 = 3.14f或3.14f double f1 = 3.14 字符类 char：2个字节，16bit无符号整数，单引号括&#39;&#39;起来的一个字符 使用Unicode编码，能够保存世界上主要语言的主要字符 Unicode常用分类：utf-8，utf-16，utf-32，Java中用的是utf-16 在java中，可以使用\\u后面跟着4个十六进制的数字的unicode来表示一个字符 char c2 = '\\u4e2d';//中 特殊字符 \\t：制表符 \\n：换行符 \\r：回车 布尔类型： boolean：适合表示比较和逻辑运算的结果，值：true/false 10 &gt; 20 数据类型的转换: 不同数据类型不能直接进行运算，需要先转换为相同类型再运算 有两种转换的方法 自动转换：也称为隐式转换，由取值范围小的向取值范围大的转换 强制类型转换: 由取值方位大的向取值范围小的转换，系统不能自动进行 (int)3.14 (数据类型)值 当byte、short、char参与运算的时候，会先把它们的数据类型转换为int，再运算 byte b1 = 10; byte b2 = 20; int result = b1 + b2; 字面量; 直接写入程序的量 float:3.14F double:3.14D long:1000L 运算符 定义：也称为操作符，是一种特殊的符号，用来表示数值的运算、赋值和比较 赋值运算符 =：把=右边的值赋值给=左边的变量或常量 复合运算符 +=：把变量的值取出来，进行加法运算，然后再把运行的结果放回变量中 -=：把变量的值取出来，进行减法运算，然后再把运行的结果放回变量中 /=：把变量的值取出来，进行除法运算，然后再把运行的结果放回变量中 *=：把变量的值取出来，进行乘法运算，然后再把运行的结果放回变量中 %=：把变量的值取出来，进行取余运算，然后再把运行的结果放回变量中 算术运算符 二元运算符：+ - * / % 一元运算符：++、-- ++：自增 ++变量：前自增 可以理解执行顺序为 int n = 2; int n = n + 1; int k = n//k可以拟为++n的表达式 变量++：后自增 可以理解执行顺序为 int n = 2; int k = n//k可以拟为n++的表达式 int n = n + 1; --：自减 –变量：前自减 可以理解执行顺序为 int n = 2; int n = n - 1; int k = n//k可以拟为--n的表达式 变量–：后自减 可以理解执行顺序为 int n = 2; int k = n//k可以拟为n--的表达式 int n = n - 1; 表达式： 定义：是符合一定语法规则的运算符和运算数的序列 表达式的值：表达式中操作数进行运算得到的结果称为表达式的值，任何表达式都有一个值 表达式的数据类型：表达式的值的类型就是表达式的数据类型 比较运算符(关系运算符)，用来对数值进行比较，表达式的结果为布尔值 ==：比较两个数是否相等 !=：不等于 &gt;：大于 &lt;：小于 &gt;=：大于等于 &lt;=：小于等于 逻辑运算符：对布尔类型进行运算 &amp;&amp;：与运算符(短路与),两边的布尔类型值同时为true，则整个表达式的值为true，否则为false 当左边的表达式的结果为false的时候，就不进行右边表达式的计算了，这种效果称为短路 如果希望运行后面的表达式，只写一个&amp;(与) ||：或运算符(短路或),两边的布尔类型值同时为false，则整个表达式的值为false，否则为true 当左边的表达式的结果为true的时候，就不进行右边表达式的计算了，这种效果称为短路 如果希望运行后面的表达式，只写一个|(或) !：非，一元运算符，对布尔值取相反的结果 三元表达式 语法：表达式1?表达式2:表达式3; 表达式1的值为布尔类型，如果为true，整个表达式的值为表达式2的值，如果为false，整个表达式的值为表达式3的值 运算符的优先级 按照操作数来划分：一元操作符 &gt; 二元操作符 &gt; 三元操作符 按运算符的类型来划分：算数运算符 &gt; 比较(关系)运算符 &gt; 逻辑运算符 &gt; 赋值运算符 运算符 优先级 类型转换 11&#x2F;&#x2F;数越大优先级越高 ++、– 10 ! 9 *、&#x2F;、% 8 +、- 7 &gt;、&gt;&#x3D;、&lt;、&lt;&#x3D; 6 &#x3D;&#x3D;、!&#x3D; 5 &amp; 4 | 3 &amp;&amp; 2 || 1 &#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D; 0 控制台读取数据Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); System.out.println(n); String z = scanner.nextInt();//读到字符串到空格结束 System.out.println(z); String y = scanner.nextLine();//读到字符串到换行结束 System.out.println(y) double x = scanner.nextDouble(); System.out.println(x); 流程控制语句条件控制语句if语句语法1： if(条件)&#123; 语句块 &#125; 如果条件为true，就执行大括号中的语句块，如果为false，该if语句直接结束 语法2：二选一 if(条件)&#123; 语句块1 &#125;else&#123; 语句块2 &#125; 如果条件为true，就执行语句块1，如果为false，就执行语句块2 语法3：多选一 if(条件1)&#123; 代码块1 &#125;else if(条件2)&#123; 代码块2 &#125;else if(条件3)&#123; 代码块3 &#125;...else&#123; 代码块n &#125; 语法4：嵌套 if(条件1)&#123; 代码块1 &#125;else&#123; if(条件2)&#123; 代码块2 &#125;else &#123; 代码块 &#125; &#125; switch语句语法: switch(表达式)&#123; case 值1: 语句块 [break]; case 值2: 语句块 [break]; ... default: 语句块 &#125; 执行过程： 计算switch后表达式的值 把该值与case后的值进行比较，如果找到相等的，则运行该case后的语句块，而不管后面的case条件是否满足，直到碰到break语句或结束switch语句的&#125;为止 注意： 表达式的值只能接收int,byte,short,char,Sring类型，不支持其他类型 不允许有重复的case取值 只能进行等值运算 case之间以及default没有顺序，先判断case，再执行default 如果default在写case前面，又没有在default语句中使用break，依然会有向下贯穿的执行效果 循环控制语句While语句语句: while(条件表达式)&#123; 循环体(语句块) &#125; 执行过程： 计算条件表达式的值，如果该表达式的值为true，执行该循环体中的语句块 然后再判断表达式的值是否为true，如果为true，再执行循环体语句，直到值为false为止 break：退出当前循环(用于循环和switch)do…while语句： do&#123; 循环体语句 &#125;while(条件); 执行过程： 先执行循环体内的语句块，然后再判断条件是否为true，如果为true，再次执行循环体，如果为false，则退出循环 与while的区别：do...while循环至少会执行一次，while可能一次都不执行 for语句： for(初始化表达式;循环条件表达式;循环后表达式)&#123; 循环体语句 &#125; 执行过程： 先执行初始化表达式，在整个循环过程中，该表达式只执行一次 执行循环条件表达式，如果该表达式的值为true，执行循环体语句块，然后执行循环体后表达式 再判断循环条件表达式的值是否为true，如果为true，继续执行循环，若为false，退出循环 注意： 在初始化表达式中，可以定义多个类型相同的变量，直接用,分隔开 continue作用：跳过本次循环的剩余语句，执行下一次循环(只能用于循环) 嵌套循环 定义：在循环体中包含另一个循环，称为嵌套循环 循环体内称为内循环，外面的循环称为外循环 执行过程： 外循环执行一次，内循环执行一遍 数组 定义：数组可以看成是多个相同的数据类型的数据组合，目的是实现对这些数据的统一管理 数组元素：数组中的每一个数据，称为数组的一个元素，数组中的元素可以是任意类型 数组的长度：数组中元素的个数，数组一旦创建，数组的长度就不能再改变(数组名.length) 数组的声明 数据类型[] 变量名; 数据类型 变量名[];&#x2F;&#x2F;极不推荐 数组的创建 new 数据类型[数组的长度]; 数组创建后，基本数据类型的元素的默认值为0(boolean:false,char:&#39;\\u0000&#39;)，引用类型元素的默认值为null; 数组的初始化：数组创建的时候，直接指定元素的值 动态初始化：使用new关键字初始化 int[] scores = new int[](45,67,89); int[] scores; scores = new int[](45,67,89); 静态初始化：不使用new关键字进行初始化 int[] scores = &#123;45,67,89&#125;;//只能在声明的同时进行静态初始化 数组的访问： 数组使用下标来访问元素，下标(索引号)从0开始 语法： 数组名[下标&#x2F;索引号] 数组的第一个元素：数组名[0] 数组的最后一个元素：数组名[数组名.length - 1] 注意：数组越界异常：java.lang.ArrayIndexOutOfBoundsException 为数组元素赋值：数组[下标] &#x3D; 值 常用算法 最值问题 int max = arr[0]; for(int i = 1 ; i &lt; arr.length ; i++)&#123; if(arr[i] > max)&#123; max = arr[i]; &#125; &#125; 冒泡排序&#x2F;选择排序 Arrays.sort(); 查找问题 foreach语句(语法糖)：遍历数组的所有元素 for(数组元素的数据类型 变量名 : 数组名)&#123; 循环体语句块 &#125; Arrays：该类是数组工具类，包含了数组的一些常见操作，比如排序 Arrays.sort(数组名),对数组中的元素进行升序排序 Arrays.toString(数组名),该方法能够以制定的格式返回数组中每一个元素连接成的字符串 Arrays.copyOf(原数组,新数组的长度)：返回新创建的数组长度是指定的，并拷贝原数组中的元素到新数组中 int[] arr = &#123;5,2,10,8,4,5&#125;; Arrays.sort(arr); for (int ele :arr)&#123; System.out.println(ele); &#125; for (int i = arr.length-1;i >=0 ; i--)&#123; System.out.println(arr[i]); &#125; int[] arr2 = Arrays.copyOf(arr,10); System.out.println(Arrays.toString(arr2)); System.out.println( Arrays.toString(arr)); 方法的定义与调用 定义:也称为函数，方法是完成某个功能的一组语句，通常将常用的功能写成一个方法 好处： 代码重用 简化了程序的编写和维护 定义语法 返回值类型 方法名(数据类型 变量名,数据类型 变量名,...)&#123; 方法体语句块 return 返回值; &#125; 返回值的类型：用来说明该方法的结果的类型 意义:把方法处理的结果返回给调用者，由调用者决定如何处理 注意:return语句表示方法结束，退出方法执行，其后不能有语句，否则编译报错 方法名：调用的时候使用，引用的标识符 方法的参数： 方法定义的时候的参数：形式参数，简称形参 方法调用的时候的参数：实际参数，简称实参 方法调用时的内存情况 栈：先进后出，后进先出 当调用一个方法的时候，会创建一个栈帧，用来处理当前方法，保存方法中的参数，局部变量，操作数栈 当方法结束调用，栈帧被覆盖 方法重载 定义：就是在同一个类中允许同时存在一个以上的同名的方法 判定重载的依据： 方法名称相同 参数列表必须不同(参数个数不同，参数类型不同) 方法的返回值类型可以相同，也可以不同 作用或好处：方法名称重用 方法的值传递 Java中的参数传递是基于值传递，但是这里的值有两种情况：基本数据类型，引用类型的值 对于基本数据类型，值传递意味着将实际的值复制到方法中的新变量。所以在方法内对参数的任意修改者仅限于方法内部，不会影响到调用者中的原始变量 对于引用类型，值传递意味着将引用(也就是地址)的值复制到方法中的新变量。所以在方法内部，你可以通过复制的引用来修改对象的状态，这个影响到调用者看到的对象。但是不能改变调用者中引用变量本身的值 public void test()&#123; int a = 1; int[] arr = &#123;1,2&#125;; System.out.println(Arrays.toString(arr)); method1(a,arr); System.out.println(Arrays.toString(arr)); method2(arr); System.out.println(Arrays.toString(arr)); &#125; public int[] method1(int a ,int[] arr)&#123; arr = new int[]&#123;100, 2&#125;; return arr; &#125; public int[] method2(int[] arr)&#123; arr[0] = 100; return arr; &#125; 面向对象组成 面向对象编程 (OOP) 面向对象设计 (OOD) 面向对象分析 (OOA) 面向对象和面向过程面向对象 类：是一个模板，它描述了一种特定类型的对象应有的状态和行为 对象：是一个类的实例。你可以根据一个类创建多个对象，每个对象都有其自己的状态，但共享同样的行为 类定义的语法结构[类修饰符] class 类名&#123; 类的成员 &#125; 类的成员 成员变量(属性)：对象的状态、情况的描述(name、age) 成员方法：对象的行为(叫，跑，跳等) 编码规则 类名：每个单词首字母大写 属性名方法名：驼峰命名法(第一个单词首字母小写，后续单词首字母大写,例如hitDog()) 成员变量和局部变量 成员变量：定义在类中，方法外，有初始值，引用类型的初始值是null，基本数值类型是0，布尔类型是false 作用域：在当前类中都可以访问 局部变量：定义在类的方法中，没有初始值，如果没有被赋予值就不能使用 作用域：从定义局部变量的位置开始到定义该局部变量的大括号结束 创建对象 语法： 类名 对象名 = new 类名(); 使用对象的属性和方法 使用点操作符访问对象的属性与方法 创建对象的原理(过程) 在堆内存中保存对象的属性 在栈帧中保存对象的地址 对对象的所有操作只能通过引用完成，一旦引用出栈，如果没有任何引用指向该对象，该对象就成为垃圾 匿名对象 创建完对象，直接调用这个对象的方法，这样的对象称为匿名对象 注意：匿名对象调用一次方法后，就成为了垃圾 垃圾回收机制 原因：当没有对象引用指向原先配给某个对象的内存时，该内存成为了垃圾，JVM的一个系统线程会自动释放该内存 注意：垃圾只作用于堆内存，与栈内存无关 构造方法 定义：也称为构造器，也是一个方法，但是是一个特殊的方法(与类同名，没有返回类型) 特点 与类同名 没有返回值，不写返回值类型，也不写void 也不能在方法中用return语句返回值 注意： 一个类可以不写构造方法，编译器会自动给这个类添加一个public的构造方法，该构造方法没有参数，称为”默认的空构造器”，如果给类添加了任意构造方法，系统(编译器)就不会再提供默认的构造器了 构造方法可以重载，构造方法可以像普通方法一样进行重载，通常一个类中可以有不止一个的构造方法，让使用者根据情况灵活调用 对象创建的详细过程(Dog dog &#x3D; new Dog();) 类加载，当JVM首次遇到一个类的时候，它会加载这个类。 类初始化：JVM会执行静态初始化块和静态变量的初始化 对象的创建: 使用new关键字创建一个新对象时，JVM会为该对象分配内存，会为成员变量赋予默认值 成员变量初始化 class Dog&#123; int age = 5;//成员变量初始化 &#123; age = 10; System.out.println(\"haha\") &#125; &#125; 执行代码块(在执行初始化后执行) class Dog&#123; int age = 5;//成员变量初始化 &#123; age = 10; System.out.println(\"haha\") &#125; public Dog(int a)&#123; &#125; &#125; this关键字 定义：代表对象自身的引用 一个引用(值是对象的地址) 指向调用该方法的当前对象 可以在调用其它构造方法的时候使用 语法：this(其它构造方法的参数列表) class Tiger&#123; String name; Tiger(String name)&#123; this.name = name; &#125; Tiger()&#123; this(\"泰格\"); &#125; Tiger retSelf()&#123; &#125; &#125; 注意:只能是构造方法的第一条语句 必须使用this的地方 区分实例变量和形参 调用其他的构造函数 返回对象自身的引用 继承 定义：也称为泛化，继承是子类自动共享父类属性的方法和机制，在定义类和实现一个类的时候，可以在一个已经存在的类的基础上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入自己的若干新内容 语法 class 类名 extends 父类名&#123; &#125; 被继承的类称为父类或超类，继承的类被称为子类或派生类 被继承的好处 代码重用 使得编程更高效 易于维护 注意：子类继承父类除了构造方法之外的所有属性和方法 Java只支持单继承，即只能有一个直接的父类 子类实例化的过程 子类实例化的时候，先实例化父类，在实例化子类 调用父类的构造方法，再调用子类的构造方法 super关键字 super()：调用父类的构造方法 注意：只能出现在子类的构造方法中，其必须是第一行，可以根据super方法的参数决定调用父类的哪个构造方法 如果子类构造器中没有使用super()，调用父类的构造方法，那么编译器会默认添加super()。调用父类的无参数构造方法，如果父类没有无参数构造方法，则会报错 super：表示指向父类的引用 在子类的方法中，明确表示使用父类中定义的成员变量或方法 在调用super()之前，不能使用super关键字、 super和this super：表示指向父类对象的引用 this：表示指向本地对象的引用 super():调用父类的构造方法 this()：调用自己其他的构造方法 包 用途： 有助于避免命名冲突 包允许将类组合成较小的单元 包允许在更大的范围内保护类，数据和方法 语法 package 包名; //例 package com.neu.opp2; com neu oop2 Dog.java 注意： 在java中位于包中的类，在文件系统中存放位置必须有包层次相对应的目录结构 package语句作为java源程序的第一条语句 每个源文件只能声明一个包 如果没有package语句，则默认为无名包(default package) 类的完全限定名 &#x3D; 包名+类名 常见包：java类库中常用的包 java.util：工具包(Scanner,Arrays) java.lang：默认包，任何程序中，该包自动导入 访问包中的类 访问同名包中的类直接访问，不需要导入该包 访问不同包中的类使用import语句导入其他包中的类 使用import语句注意： 必须在package声明后，类声明前 import可以出现多次 import语句中可以使用通配符(*) 使用通配符会影响编译的速度，比直接导入包中的类要慢，不会影响运行速度 访问权限修饰符 public：共有的，在任何类中都可以访问，没有任何的限制 default(friendly)：默认的，包内可见，在该类所在的包中的其他类中都可以访问，包外的类不能访问 private：私有的，不对外公开 private的修饰成员变量和成员方法只能在当前类中使用，其他任何类都不可以访问 protected：受保护的，子类可见和包内可见 可见性：public，protected，default，private 封装 面向对象三大特性：封装继承多态 封装性:主要理念是”信息隐藏”。封装是将对象的状态(属性、数据)和行为(代码)包装在一个单一的单位(类) 中。这种机制可以防止数据的直接访问。只能通过预先定义的方法(getter,setter)来访问，这样我们就可以隐藏类的内部实现细节，提高了代码的安全性 好处： 增强安全性 提高了代码的复用性和可维护性 通过控制成员的访问方式，对成员的访问进行更精细的控制 在 java中，封装性是使用访问权限修饰符来实现的 方法覆盖(方法重写) 定义：子类继承父类后，子类对继承来的方法进行改造 判定规则 名称相同 参数列表相同 返回值类型相同 子类覆盖方法的访问权限不小于父类被覆盖方法的访问权限 不能抛出父类里没有抛出的异常 引用类型转换 向上转型：也称为父类的引用指向子类对象，把子类自动地转换为父类 注意：损失了子类特有的属性和行为 向下转型：把父类转换为子类，需要强制转换 注意：把同一类型向上转换，再向下转换，编译没有错误，否则直接转换就会报错 Animal a = new Cat(\"小白\",100); Dog dog = (Dog)a; //编译不报错 Cat cat = new Cat(\"小白\",100); Dog dog2 = (Dog)cat;//编译报错，因为没有向上转换 instanceof(比较运算符) 定义：用来测试一个对象是否为某个类型的实例 Animal a = new Cat(\"小白\",100);if(a instanceof Dog)&#123; Dog dog = (Dog)a;Jelsef system.out.print]n(\"a不是Dog类型，不能转换\");&#125; 用途：可以在进行向下转型前判断，是否能进行强制转换 多态 定义：多种形态，指的是同一个类的不同对象，对同一个行为的不同反应 判定多态的条件 继承 重写 父类的引用指向子类对象 面向对象的设计原则 开闭原则：对修改关闭，对拓展开放 多态性也称为动态绑定、迟绑定、运行期绑定 在编译时，在Animal中查找hitted()方法 如果hitted()方法不是private、static、final，也不是构造方法的话，编译器生成动态绑定指令，否则生成静态绑定指令 在运行时，JVM发现是动态绑定指令，根据animal对象的实际类型Dog，先调用Dog的hitted()，如果没有重写hitted()，则调Animal中的hitted() 好处：实现了代码的可拓展性 练习题：实现停车场收费功能，卡车每小时10元，轿车：每小时5元，公共汽车：每小时8元 static 可以修饰的元素 成员变量(属性) 成员方法 代码块 注意：局部变量不能用static修饰 修饰成员变量(静态变量) 类变量，其值所有对象共享 生命周期：在类加载后的类初始化阶段，声明静态变量，只要类对象存在，静态变量就存在 访问方式 实例化后访问 (通过对象来访问)：对象名.静态属性名(不推荐) 直接通过类名来访问：类名.静态属性名 修饰方法(静态方法) 类方法，不需要实例化就可以直接访问的方法 访问方式 直接访问：类名.方法名() 对象访问：对象名.方法名() 注意： 静态方法只能直接访问静态的成员，不能直接访问非静态的成员 修饰代码块 定义：一个类中由static修饰的，不包括在任何方法中的代码块 生命周期：在类加载后执行静态代码块，且只能执行一次 非静态代码块，在每次创建实例的时候都会进行一次 作用：可以用来为静态变量赋予初始值，或者执行一些只执行一次的代码 单例设计模式 定义: 保证一个类仅有一个实例，并提供一个访问它的全局访问点 实现过程 构造方法私有化 就只能通过类来访问其中的静态方法 静态方法只能访问静态成员 public class Teacher &#123; private Teacher()&#123; &#125; private static Teacher teacher = new Teacher(); public static Teacher getTeacher()&#123; return teacher; &#125; &#125; public class TestTeacher &#123; public static void main(String[] args) &#123; Teacher.getTeacher(); &#125; &#125; abstract 修饰类：抽象类，不能被实例化的类 abstract class 类名&#123; &#125; 作用：让子类去继承 修饰方法：抽象方法，只有方法的声明，没有方法的实现(没有实现体)的方法 abstract class 类名&#123; abstract 方法声明; &#125; 注意： 抽象方法必须放在抽象类中 作用：让子类去重写 在下列情况下，类必须声明为abstract： 当一个类中包含抽象方法时 当一个类继承了父类的抽象方法，又没有全部重写的时候 final 可修饰的元素 类：不能被继承 方法：不能被重写 成员变量和局部变量：不能被改变 public class Student&#123; final int score;//成员变量一旦用final修饰就没有默认值了 //通过构造方法为final变量赋予初始值 public Student(int score)&#123; this.score = score; &#125; &#125; 注意： 修饰成员的时候，声明时赋值，或者在构造方法中赋值，否则报错 常量 定义：一旦赋值就不能再改变 命名规范：标识符全部字母大写，单词间用下划线分割 注意：如果常量是类的成员，建议添加static修饰，成为类变量 接口 定义：接口对类来讲是一套规范，是一套行为协议 语法规则 interface 接口名&#123; [public static final]常量 = 初始值; [public abstract]抽象方法 &#125; 类实现接口 class 类名 implements 接口名&#123; &#125; 实现一个接口意味着：去实现(重写)这个接口中所有抽象的方法或者实现部分方法，再把自己声明为抽象的 一个类可以同时实现多个接口 class 类名 implements 接口名1, 接口名2,...&#123; &#125; 一个类可以继承一个父类，实现多个接口 class 类名 extends 父类名 implements 接口名1, 接口名2,...&#123; &#125; 接口继承接口 interface 接口名 extends 接口名1,接口名2&#123; &#125; 接口的好处：在不同类型中抽取了共同的行为，他们在实现接口的功能上是可替换的 面向对象的设计原则：针对接口编程，而不针对实现编程 接口作为方法返回值的意义： 实际就是把这个接口的实现类对象返回给调用者 接口的补充 从jdk8开始，接口添加了一种新功能——默认方法，默认方法允许接口方法定义实现，而所有子类都拥有该方法的实现 好处：提供一种扩展接口的方法啊，而不破坏现有的代码 注意：默认的方法在子类中可以被重写 interface 接口名&#123; [public static final]常量 = 初始值; [public abstract]抽象方法 默认方法(default 返回值类型 方法名(参数列表)&#123; 方法体 &#125;) &#125; 异常处理概述 定义：程序运行时错误 Java中错误的种类 编译错误：语法错误导致 运行时错误(异常) 异常的危害： 程序被终止 内存泄漏 异常类的继承关系 Throwable：可以被抛出的错误 Error：指的是应用程序运行期间发生的严重错误，如:虚拟机内存耗尽，堆栈溢出，一般是灾难性的，没有必要使用异常处理机制 Exception：可以通过异常处理机制处理的错误 以IOException代表的异常：检查性异常，依赖于程序的运行环境，无论如何也不可能完全通过测试排除掉 以RuntimeException为基类的异常：非检查性异常，通过反复测试能够把所有异常排除掉 异常处理机制异常如何产生在程序运行过程中，如果发生异常事件，系统就会发出错误报告，这时候系统将会产生一个异常对象，该对象封装了异常相关的信息，并将其提交给Java运行时环境 异常如何处理 自行处理：把可能发生的异常语句封入到try块中，而处理异常的语句封入到catch中 回避处理：在方法声明中包含throws语句，通过潜在的调用者来处理异常 异常处理语句 try…catch try：该代码块中放入可能发生异常的语句 catch：用来捕获并处理try块中抛出的异常代码块，没有try块，catch不能单独存在，可以有多个catch块用来捕获不同的异常 每次从try块中抛出异常，系统会从上向下往每个catch块中传递参数，直到遇到一个类型匹配的catch块为止 finally语句 放在try…catch语句后 finally语句中的代码块不管异常是否发生，是否被捕获到，总是要执行 即使try块和catch块中使用return或break语句，finally语句块都是要执行 当执行System.exit()：表示退出系统，finally语句不会再执行 finally语句主要用来释放程序占用的系统资源 throws语句 如果一个方法中的语句块在运行时可能发生异常，但是不确定如何处理，则可以在程序方法的声明后使用throws关键字表明方法中可能有这些异常抛出 throws语句后面可以跟多个异常类型，中间用逗号分隔 throw语句 异常是使用throw语句抛出的，可以使用throw语句引发明确的异常 throw语句用在方法体中，表示抛出异常，由方法体语句处理或采取回避处理 与throws的区别 throws表明方法可能抛出异常，写在方法的声明中，对调用者的提示 throw表明抛出异常对象，写在方法体内 对检查性异常和非检查性异常的处理 非检查性异常：可以处理，也可以不处理(需要大量的测试找出所有异常) 检查性异常：必须处理(要么处理，要么回避) 为什么不都是异常处理机制 大量使用异常处理语句会使得代码的可读性差 对代码进行异常检查会使得编译较慢 异常对象的常见方法 getMessage()：得到异常的消息 printStackTrace()：打印栈(堆栈)的跟踪信息 方法调用堆栈 定义：方法A调用方法B时，只有完成方法B，A才能完成，先执行的方法总是后完成，后执行的方法总是先完成 在方法调用的堆栈中的某个方法中的语句抛出异常，会导致所有方法都不能正常结束，如果不想出现这种情况，就要使用java的异常处理机制进行处理 自定义异常： 定义：如果Java提供的异常类型不能满足程序设计的需要，可以自定义异常类型 用户自定义的异常应该继承Exception或其子类 检查性异常：Exception 非检查性异常：RuntimeException 注意 自定义异常的名称很重要，要尽可能反映异常的功能 可以添加一个有参数的构造方法来传递异常的信息 应该自己检查异常发生的条件，抛出异常 工具类API 定义：应用程序编程接口 是JDK提供的各种功能的java类和接口等 Object Object是所有类的超类，Object是java中唯一一个没有父类的类 一个类可以不是Object的直接子类，但一定是Object类的子类 意义：在Object类中定义的方法，在任何类中都可以使用 equals()方法 public boolean equals(Object obj) 功能：比较两个对象的引用是否相等 hashCode()方法 public int hashCode() 功能：返回一个对象的哈希码，一个对象的哈希码是代表对象的一个整数，比作对象的身份证号，默认的哈希码是一个对象内存地址做某种转换得到的，所有不同的对象有不同的哈希码 java的规定，如果调用equals方法返回两个对象相等的，那么在这两个对象上调用hashCode()方法返回值的整数也必须是相等的 toString public String toString() 功能：返回一个字符串，格式：完全限定名@哈希码(十六进制整数) equals()方法和&#x3D;&#x3D;的区别 equals()方法只能比较引用类型，不能比较基本数据类型，&#x3D;&#x3D;，既可以比较引用类型，也可以比较基本数据类型 默认情况下(子类没有重写Object类的equals()方法)，equals()方法只能比较对象的引用是否相同 &#x3D;&#x3D;如果比较引用类型就是比较地址是否相同 包装类 在java中基本数据类型变量不是对象，通过包装类将基本数据类型看作对象 目的：把基本数据类型转换为对象，就可以同其他的对象统一处理使用了 每一种基本数据类型都有对应的包装类，大多数包装类的命名方法为：基本数据类型单词首字母大写，有两个不同 char&#x3D;》Character int&#x3D;》Integer 自动装箱和拆箱 自动装箱：把基本数据类型转换为包装类 自动拆箱：把包装类中的值取出来 如: Integer i = 10; int j = i; 基本数据类型转换为字符串 String s &#x3D; 10+””; String s &#x3D; Integer.toString(10); 把字符串转换为基本数据类型 int n &#x3D; Integer.parseInt(“100”); String 定义:一组不可改变的Unicode字符序列，对它的任何修改实际上产生了一个新的字符串 字符串的创建 静态方式：使用字符串字面量赋值 String s = \"abc\"; 两个采用静态方式创建的字符串，如果字面量相同，那么在方法区的常量池中，只产生一个字符串对象，即这两个字符串变量的引用相同 动态方式：使用内存分配符(new) String s = new String(\"tom\"); 字符串的常用方法 boolean equals(Object obj)：比较字符串的内容是否相等 boolean equalslgnoreCase(String str):字符串忽略大小写比较 String toUpperCase()：把字符串中小写字母转换为大写 String toLowerCase()：把字符串中大写字母转换为小写 char charAt(int index)：返回字符串中指定索引处的字符，如果index超出指定的范围，抛出字符串索引越界异常，index从0开始 int length()：返回字符串中字符的个数 String substring(int beginindex)：从指定的索引处开始截取字符串，到字符串结束位置 String substring(int beginindex,int endindex)：从指定的索引处开始截取字符串，到结束索引号为止(不包括结束索引对应的字符) int indexOf | lastindexOf(String|char)：在字符串中查找一个指定的字符串或字符第一次或最后一次出现的位置，如果没有找到，返回-1 String trim()：返回字符串去掉首尾空格后的字符串 String split(String str):使用指定的分隔符分割当前字符串，返回分隔后的元素组成的数组 String replace(char|String,char|String)：使用新的字符串或字符替换原来的字符串或字符 int compareTo(String):比较两个字符串的大小，相等返回量，当前字符串大返回大于零的数，否则返回小于零的数 StringBuffer 定义：可以改变的字符序列，可以动态改变，而不产生额外的对象 构造方法： StringBuffer()：创建了一个其中不带有字符串的字符串缓冲区，初始容量为16个字符 StringBuffer(int capacity)：创建一个具有指定容量的字符串缓冲区 常用方法 append(String value)：在原来字符串后面追加字符串 toString()：得到StringBuffer中的字符序列 int length()：返回字符的个数 int capacity()：得到缓存区容量的大小 setChar(int index,char c)：修改index处的字符 insert(int index,String str)：在index处插入指定的字符串 deleteCharAt(int index)：删除指定index处的字符 delete(int start,int end)：删除指定索引号之间的字符 StringBuilder StringBuilder设计用来作为StringBuffer的简单替代，用在字符串缓冲区被单线程方法使用的情况 其他使用方法与StringBuffer完全一样。 Math Math类提供了大量数学运算的方法 Math类是final类，不能被继承 Math类中的方法都是静态的，不用实例化直接通过类名访问 常量 Math.PI：圆周率 Math.E：自然对数的指数 常用方法 abs()：求绝对值 ceil(double)：向上取整 floor(double)：向下取整 random()：返回0到1之间的随机数 (int)(Math.random()*35)+1; round(double)：四舍五入 sqrt(double)：开方 Date 包：java.util.Date 表示特定的瞬间，精确到毫秒，在内部，保存自1970年1月1日00:00:00到某一时刻间隔毫秒数 getTime()：得到内部时间毫秒数，long类型 new Date()：得到一个当前时间的日期对象 new Date(long time)：根据参数指定的毫秒数，创建一个对应的日期对象 该类的许多方法都过时了，过时的方法在未来高版本的JDK中可能就不在支持了，建议别用 toString()：返回日期的字符串表示形式 befor(Date)：判断当前日期是否在参数给定的日期前，在之前，返回true，否则返回false after(Date)：判断当前日期是否在参数给定的日期后，在之后，返回true，否则返回false Calendar 包：java.util.Calendar 是一个抽象类 获取Calendar类的实例 Calendar.getInstance();静态方法，得到当前时间对象 设置时间 set(int field,int value)：根据指定字段设置日期值 set(int year,int month,int date,int hours,int minutes,int seconds)：设置日期,月份从0开始 得到指定的时间部分 get(int field)：field可以使用Calendar类中定义的常量来设置 把Date转换为Calendar setTime(Date) 把Calendar转换为Date Date.getTime 为给定的日历字段添加或减去指定的时间值 add(int field,int num) SimpleDateFormat(重要) 包：java.text 构造方法： new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\") 模式字母 yyyy：4位年 MM：月 dd：日期 HH：0-23(小时) hh：0-11(小时) mm：分钟 ss：秒 String format(Date)：把日期格式化为指定格式的字符串 Date parse(String)：把字符串转换为日期对象 集合框架概述 集合也称为容器类，用来储存对象 数组的问题 长度一旦定义就不能再改变 数组要求每一个元素在内存中是挨着存放的 常用操作：增删改查 与数组比较 数组定长，集合大小可以动态调整 数组中元素可以是基本数据类型和引用类型，集合中只能储存引用数据类型 集合框架 Collection：接口 List：接口，是Collection接口的子接口，元素特点：有顺序，可重复 Set：接口，是Collection接口的子接口，元素特点：无顺序，不可重复 Map接口：键值对储存 Iterator：接口，迭代器，对Collection中的元素进行遍历访问 ArrayList 是List接口的一个实现类 数据线性存储(元素在物理存储的时候，是挨着存放的) 特性跟数组相近，简称为动态数组 构造方法 ArrayList():创建一个初始容量为10的空集合 ArrayList(int capacity):创建一个具有初始容器为capacity的空集合 常用方法： add(Object)：把元素添加到集合最后 get(int index)：根据索引号得到对应的元素，如果索引号超出一定的范围，抛出异常 add(int index,Object obj)：把元素插入到index位置，index不能超出集合中元素的个数 size()：返回集合中元素的个数 contains(Object obj)：判断集合中是否包含参数指定的对象，包含返回true，否则返回false 注意：比较的时候，使用对象的equals()方法进行比较 Object remove(int index)：移除参数指定位置的元素，返回移除后的元素 boolean remove(Object obj)：调用equals()方法移除参数指定的单个元素(移除一个元素后，比较终止)，返回true表示移除成功 set(int index,Object obj)：在指定索引处，用obj替代原来的元素 indexOf(Object obj)：查找对象第一次出现的位置，返回索引号，没有找到，返回-1 lastindexOf(Object obj)：查找对象最后一次出现的位置，返回索引号，没有找到，返回-1 toArray()：把集合中的元素导入数组，返回数组 LinkedList 是List接口的实现类 数据结构采用的双向链表，元素物理存储位置不要求连续 优缺点 优点：插入和删除节点效率高 缺点：随机访问效率不高 常用方法： addFirst(Object)：把元素插入到集合第一个位置处 addLast(Object)：把元素插入到集合的最后一个位置处 getFirst()：得到第一个元素 getLast()：得到最后一个元素 removeFirst()：移除第一个元素 removeLast()：移除最后一个元素 使用ArrayList还是LinkedList，取决于对选择的数据结构做何种操作比较多 插入和删除操作比较多，选择LinkedList 随机访问(根据索引得到元素)比较多，选择ArrayList 泛型 定义：类型参数，允许在编译时限制和检查类或方法中的类型参数 好处：提高代码的可读性，健壮性和重用性，同时减少了运行时类型错误的风险 目的：在编译时提供类型的检查，避免在运行时出现类型转换错误 语法： 在类或接口后面跟一个尖括号，其中包含类型参数，类型参数可以是类(如T)，或者接口(如E) 如何限制泛型的类型 使用界定符来限制泛型类型的范围 public class Box &lt;T extends Animal &amp; Compareable>&#123; private T content; public T getContent()&#123; return content; &#125; public void setContent(T content)&#123; this.content = content; &#125; public static void main(String[] args) &#123; Box&lt;Animal> box = new Box&lt;>(); box.setContent(new Animal()); System.out.println(box.getContent()); &#125; &#125; 虽然使用的是extends关键字，但是它同时表示类的继承和接口的实现 HashSet 是set接口的实现类 构造方法 HashSet():构造了一个容量为16的空间 常用方法： boolean add(T t)：添加元素到集合中，添加成功，返回true boolean remove(T t)：移出元素，移出成功，返回true int size()：得到元素的个数 boolean isEmpty()：是否为空合集(size() &#x3D;&#x3D; 0) clear()：清空集合 contains(T t)：判断元素在集合中是否存在，如果存在，返回true Iterator 该接口用于遍历集合(Collection)，它提供了三个主要方法 boolean hasNext()：检查集合内部是否有更多的元素 next()：返回迭代的下一个元素，并将光标向前移动一步 remove()：从底层集合中删除迭代器最后返回的元素 使用时注意：先要通过next()返回元素，，否则运行异常(IllegalStateException) 注意：单向操作 ListIterator ListIterator接口拓展了Iterator，提供了更强大的列表迭代功能 提供了双向的迭代和对列表的修改功能 hasPrevious():检查是否有上一个元素，有则返回true previous()：返回迭代的上一个元素，并将光标向后移动一步 add(T t)：会在光标当前位置插入一个元素，并使光标移动到插入到元素之后 set(T t)：操作的是最后一次调用next()或previous()返回的元素，光标的位置不变 Collections 提供了一些操作Collection接口子类的方法 常用方法 max(Collection)：找出Collection集合中最大的元素 要求Collection元素实现Comparable max(Collection,Comparable)：找出Collection集合中最大的元素，使用第二个参数作为比较器 Comparable:接口，可以比较大小的，某个类实现该接口，就意味着这个类的对象是可以比较大小的 int compareTo(Object)：返回0表示相等，返回大于0的数，表示当前元素大于参数元素 Comparator：接口，比较器接口，单独定义一个类，实现该接口 int compare(Object,Object)返回0表示相等，返回大于0的数，表示当前元素大于参数元素 min(Collection) min(Collection, Comparator) sort(List)：对List接口集合元素进行排序 sort(List,Comparator)：对List接口集合元素进行排序，使用第二个参数作为比较器 HashMap Map接口的实现类，键值对存储，键不可以重复，值可以重复，值可以为null 常用方法： put(Object,Object)：将键和值存储到map集合中，如果key存在，则替换值 Object get(Object key)：根据键得到值 Object remove(Object key)：根据key，移除键值对，返回被移除的值 boolean containsKey(Object key)：判断是否包含指定的键，包含返回true boolean containsValue(Object key)：判断是否包含指定的值，包含返回true int size()：得到键值对的个数 Set keySet()：得到键的集合 Collection values：得到值的集合 Set entrySet()：得到键值对集合 Map.Entry：键值对类型 getValue()：得到键值对中的值 getKey()：得到键值对中的键 Arraylist扩容 与 hashmap 扩容机制 ArrayList扩容:当添加元素超过当前容量的时候，通常会将数组容量增加到原来的1.5倍，并将旧的数组的内容拷贝到新数组中 HashMap扩容:当HashMap中的元素超过负载因子与当前容量的乘积时，HashMap会扩容，通常将容量增加一倍并重新计算每个元素的位置 HashMap与TreeMap的区别 HashMap使用的是哈希表，提供常数时间的访问速度 TreeMap使用红黑树，按照键的顺序排序 HashMap允许一个null键和多个null值 TreeMap不允许null键 HashMap与HashTable HashMap非线程安全，HashTable线程安全 HashMap允许一个null键和多个null值 HashTable不允许null键和null值 HashMap通常比HashTable更快，因为它不需要同步 List,Set,Map的区别 List是有顺序的元素集合，可以包含重复的元素 Set是无顺序的元素集合，不包括重复的元素 Map是由键值对组成的元素，其中键是唯一的 文件与流文件管理 java.io.File 该类主要针对文件或文件夹的路径名的管理 作用 文件属性的管理 文件的检查 文件的删除 不包括文件内容的管理 常用方法 boolean exists()：是否存在 boolean isFile()：判断是否为文件 boolean isDirectory()：判断是否为文件夹 boolean createNewFile()：创建新文件，创建成功，返回true，文件已经存在，返回false boolean mkdir()：创建文件夹 boolean mkdirs()：创建文件夹，会创建路径中不存在的文件夹 String[] list()：读取文件夹中的信息 File[] listFiles()：读取文件夹中的信息，返回File型 String getName()：得到文件名 String getPath()：得到文件路径 long length()：得到文件大小，单位为字节 boolean delete():删除文件或文件夹 boolean renameTo(File):重命名 流 数据流：一串连续不断的数据的集合 流的分类： 流的方向：输入流和输出流(以我们的程序为主来说) 处理的的单位：字节流，字符流 功能分：节点流和处理流 节点流：直接从数据源读取数据 处理流：在其他数据流的基础上，对数据进行进一步处理 FileInputStream(对文件读取字节输入流，节点流) 构造方法 FileInputStream(String filePath) FileInputStream(File file) 常用方法 int read()：从流中读取一个字节数据，返回值为读取到的内容，返回出-1，表示读取到文件结尾了 int read(byte[])：从流中读取数据到字节数组中，返回实际读取的字节数 FileOutputStream(对文件写入字节输出流，节点流) 构造方法 FileOutputStream(String filePath) FileOutputStream(String filePath,boolean append):append如果为true，表示追加内容 常用方法 void write(int)：写入一个字节数据到流中 void write(byte[])：写入多个字节数据到流中 FileReader(对文件操作，输入流，字符流) 常用方法 int read()：读取一个字符 int read(char[])：读取数据到字符数组中 package com.io; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; import java.util.Arrays; public class StreamDemo4 &#123; public static void main(String[] args) throws IOException &#123; FileReader fileReader = new FileReader(\"D:\\\\c.txt\"); char[] cs = new char[1024]; int read = fileReader.read(cs); String s = new String(cs,0,read);//把字符数组指定范围内的字符转换为字符串 System.out.println(s); fileReader.close(); &#125; &#125; FileWriter(对文件操作，输出字符流，节点流) 构造方法 FileWriter(String filePath) FileWriter(File file) FileWriter(String filePath,boolean append)：append表示是否追加，如果为true追加 常用方法 void write()：写入一个字符 void write(String)：写入一个字符串 BufferedReader(带缓冲的字符输入流，处理流) 构造方法 BufferedReader(Reader) 常用方法 String readLine()：读取一行数据 PrintWrite(字符流，处理流，输出流) 构造方法 PrintWrite(Writer); PrintWrite(String filePath) 常用方法 println(String)：写入一行数据到流中，自动加上换行符 序列化和反序列化 序列化：将对象转换为字节序列的过程 反序列化：将字节序列转换为对象的过程 序列化的过程 让序列化的对象实现一个Serializable的接口 创建ObjectOutputStream对象，使用ObjectOutputStream的writeObject(Object)，把对象写入到流中 反序列化的过程 创建ObjectInputStream对象，使用ObjectInputStream的readObject()，从流中读取对象 冒泡排序int[] arr = new int[]&#123;1,2,3,4,6,9,8,7,5&#125;; int temp = 0; for(int i = 0 ; i &lt; arr.length-1; i++)&#123; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if(arr[j] &lt; arr[j+1])&#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; 二维数组int[][] arr = new int[][]&#123;&#123;4,3,7&#125;,&#123;1,2,5,8&#125;&#125;; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr[i].length; j++) &#123; System.out.print(arr[i][j]); &#125; &#125; 线程概述 进程：正在运行的程序 多任务：多进程 多进程的作用：增加了CPU的利用率 线程：一个进程同时运行多个任务，每个任务称为一个线程 定义：是一个程序内部的顺序执行流 进程与线程的区别 本质区别：每个进程有自己一套变量，而多线程共享数据 与进程相比，线程是轻量级的，创建和销毁一个线程比启动和销毁一个进程开销要小得多 创建线程 继承Thread类，重写run方法 public class MyThread extends Thread&#123; @Override public void run() &#123; for (int i = 0 ; i &lt; 5;i++)&#123; System.out.println(Thread.currentThread().getName()+\":\"+i); &#125; &#125; &#125; MyThread myThread = new MyThread(); //启动线程 myThread.start(); MyThread myThread1 = new MyThread(); myThread1.start(); 让类实现一个Runnable接口，把该类的对象作为Thread类的构造参数 public class MyThread2 implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName()+\":\"+i); &#125; &#125; public static void main(String[] args) &#123; MyThread2 my = new MyThread2(); Thread thread = new Thread(my); thread.start(); Thread yuanshen = new Thread(my); yuanshen.start(); &#125; &#125; 多线程的意义 可以在一个程序中实现多个任务 提高资源利用率 线程的状态(Thread.State) NEW：新生态，线程对象被创建，但是没有启动 RUNNABLE：可运行状态(就绪状态)，已经启动了start()方法，有可能正在运行，也可能等待cpu调度执行 BLOCKED：阻塞态，由于当前线程缺少资源，无法继续运行 WAITING：等待状态(等待唤醒) TIMED_WAITING：等待定时器结束 TERMINATED：结束状态 常用方法： Thread.sleep(long)：休眠指定的毫秒数 Thread.currentThread()：得到当前线程 getName()：得到线程名 getState()：得到线程状态 isAlive()：判断当前线程是否还在运行 join()：加入一个线程，直到它结束 package com; public class Mather extends Thread&#123; @Override public void run() &#123; System.out.println(\"妈妈开始做饭...\"); System.out.println(\"妈妈发现酱油没有了\"); System.out.println(\"妈妈等待儿子打酱油\"); Son son = new Son(); son.start(); try &#123; son.join(); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(\"妈妈继续做饭\"); &#125; public static void main(String[] args) &#123; Mather mather = new Mather(); Son son = new Son(); mather.start(); // son.start(); &#125; &#125; class Son extends Thread&#123; @Override public void run() &#123; System.out.println(\"儿子去打酱油\"); for (int i = 1; i &lt;= 10; i++) &#123; try &#123; Thread.sleep(100); System.out.println(\"去了\"+i+\"分钟\"); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125; System.out.println(\"酱油买回\"); &#125; &#125; 线程同步 原因：有时两个或多个线程可能会试图访问同一个资源，可能导致数据不一致的现象 解决：使用线程同步，确保对受保护资源的访问必须是串行化的 同步化代码块 package com; public class Ticket implements Runnable&#123; private int no = 100; @Override public void run() &#123; try &#123; Thread.sleep(1); while (no >=1)&#123; synchronized (this)&#123; if(no >= 1)&#123; System.out.println(Thread.currentThread().getName()+\",\"+no); no--; &#125; &#125; &#125; &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) &#123; Ticket ticket = new Ticket(); new Thread(ticket).start(); new Thread(ticket).start(); &#125; &#125; 同步化方法和同步化代码块 不同点 同步化代码块可以锁定任意对象，同步化方法只能锁定当前对象 同步化方法，把当前方法内的所有代码都锁定了，使得方法的执行完全串行化，有可能锁定的范围过大，同步化代码块可以更精确的控制要定的代码 同步化方法在方法的声明中可以看见该方法是受到保护的，而代码块不行 线程的优先级 线程调度器是根据线程的优先级从就绪状态中选择运行的线程 线程优先级是高度依赖操作系统的 我们程序的算法不要依赖与线程的优先级 setPriority(int)：值的范围1~10，默认是5 死锁：两个线程彼此等待对方占据的锁 程序调试 作用： 查看程序执行过程 查看内存数据的变化情况 查找程序逻辑错误 步骤 设置断点 进入Debug模式 运行停止在断点处(当前代码没有执行) 步过(执行当前行代码) Idea快捷键：F8 恢复程序(执行到下一个断点处，如果没有下一个断点，程序执行到结束) Idea快捷键：F9 停止(直接停止程序调试) Idea快捷键：Ctrl+F2 使用评估窗口：计算表达式的值","categories":[{"name":"Java","slug":"Java","permalink":"http://yiyecreb.top/categories/Java/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"高精度算法","slug":"高精度算法","date":"2023-07-23T16:00:00.000Z","updated":"2023-07-24T12:09:56.915Z","comments":true,"path":"2023/07/24/高精度算法/","link":"","permalink":"http://yiyecreb.top/2023/07/24/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95/","excerpt":"","text":"高精度算法高精度加法//1.输入两个整数a,b，输出他们的和(a,b≤10^9) //2.输入两个整数a,b，输出他们的和(a,b≤10^500) /*分析:int : -2^31~2^31-1，数量级为10^9 long long:-2^63~2^63-1,数量级为10^18 解决方法：用数组模拟高精度*/ 算法核心： c[i] +&#x3D; a[i] + b[i]; c[i+1] &#x3D; c[i] &#x2F; 10; c[i] &#x3D; c[i] % 10; //1.字符串读入 //2.字符串转数组 //3.竖式加法 //4.消前导零 //5.倒序输出 Java的高精度加法import java.math.BigInteger; import java.util.Scanner; public class HighPrecisionAdd &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); String x = scanner.nextLine(); String y = scanner.nextLine(); BigInteger bigx = new BigInteger(x); BigInteger bigy = new BigInteger(y); BigInteger sum = bigx.add(bigy); System.out.println(\"和为\"+sum); &#125; &#125; C++的高精度加法#include &lt;bits&#x2F;stdc++.h&gt; using namespace std; string x,y; int a[10000],b[10000],c[10000],la,lb,lc; int main()&#123; cin &gt;&gt; x &gt;&gt; y; la &#x3D; x.length(); lb &#x3D; y.length(); for(int i &#x3D; 0; i &lt; la ; i++)&#123; a[la-i] &#x3D; x[i] - &#39;0&#39;; &#125; for(int i &#x3D; 0; i &lt; la ; i++)&#123; b[lb-i] &#x3D; y[i] - &#39;0&#39;; &#125; lac &#x3D; max(la,lb); for(int i &#x3D; 1; i &lt;&#x3D; lc ; i++)&#123; c[i] +&#x3D; a[i] + b[i]; c[i+1] &#x3D; c[i] &#x2F; 10; c[i] %&#x3D; 10; &#125; if(c[lc+1] &gt; 0)lc++; for(int i &#x3D; lc ; i &gt;&#x3D; 1 ; i--) count &lt;&lt; c[i]; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yiyecreb.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"常见的DOS命令","slug":"DOS","date":"2023-07-22T16:00:00.000Z","updated":"2023-07-23T03:28:44.309Z","comments":true,"path":"2023/07/23/DOS/","link":"","permalink":"http://yiyecreb.top/2023/07/23/DOS/","excerpt":"","text":"常见的DOS命令 exit：退出当前DOS命令窗口 cls：清屏 DOS窗口中的内容复制：在DOS窗口的任意位置点击鼠标右键，点击标记，选择要复制的内容，在任意位置点击右键，在需要粘贴的位置粘贴即可（我的评价是不如CV） dir：列出当前目录下的所有子文件&#x2F;子目录 cd命令：change directory【改变目录】 cd命令用法： cd目录的路径：包括绝对路径和相对路径 绝对路径:表示该路径从某个磁盘的盘符下作为出发点的路径 相对路径:表示该路径从当前所在的路径下作为出发点的路径 假设当前所在的路径是C:\\Users \\Administrator,那么在此时输入cd Desktop,那么其中Desktop就是一个相对路径，从当前所在的C:\\Users\\Administrator这个路径作为出发点,开始找Desktop目录。 假设是这样写的:cd C:\\Users\\Administrator\\Desktop,其中C:\\Users\\Administrator\\Desktop路径就是一个绝对路径。 cd .. 回到上级目录 cd \\ 直接回到根目录 切换盘符： c: d: e: f:","categories":[{"name":"DOS","slug":"DOS","permalink":"http://yiyecreb.top/categories/DOS/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"MySQL","slug":"MySql","date":"2023-07-17T16:00:00.000Z","updated":"2023-07-28T02:06:09.293Z","comments":true,"path":"2023/07/18/MySql/","link":"","permalink":"http://yiyecreb.top/2023/07/18/MySql/","excerpt":"","text":"MySQL表连接 全外连接:MySQL不支持,使用union来解决 union是MySQL中用来组合两个或多个select语句的结果集的一个操作符 基本语法: SELECT COLUMN_NAME(S) FROM TABLE1 UNION SELECT COLUMN_NAME(S) FROM TABLE2 使用规则: union内的每个select语句必须拥有相同数量的列，并且对应列也拥有兼容的数据类型 union会去掉重复行 如果不想去掉重复行：使用union all SQL DQL:数据查询语言:select DML:数据操作语言,insert,update,delete DDL:数据定义语言:create,alter,drop DCL:数据控制语言:grant,remoke TPL:事务控制语言,commit,rollback,savepoint DML插入语句语法: insert into 表名 (列名列表) values (对应值的列表) 列名列表可以省略，对应值输入的顺序与表的设计顺序一致，而且每列都要插入值 插入空值 列名列表中不写值为空的列 值设置为空(null) 一次插入多行记录 insert into 表名(列名列表) values (对应的列表),(对应的列表),(对应的列表)... insert into 表名(列名列表) 子查询; insert into emp_copy select * from emp where DEPTNO = 10; 快速创建表(DDL)create table 表名 as 子查询; create table emp_copy as select * from emp where 1 &lt;> 1; 更新语句语法: update 表名 set 列名 = 值,列名 = 值,列名 = 值,列名 = 值,列名 = 值,列名 = 值... [where 条件] 例题: -- 把员工的工资改为其部门的平均薪水 update emp e1,(select DEPTNO,avg(sal) avgsal from emp group by DEPTNO ) e2 set e1.SAL = e2.avgsal where e1.DEPTNO = e2.deptno; update emp e1 join (select DEPTNO,avg(sal) avgsal from emp group by DEPTNO ) e2 on e1 .DEPTNO = e2.DEPTNO set e1.SAL = e2.avgsal; 删除语句语法: delete from 表名 [where 条件] 例题: -- 3.删除工资大于所在部门平均工资的员工记录 delete from emp where EMPNO in (select EMPNO from (select e2.EMPNO from emp e2 join (select DEPTNO,avg(sal) avgsal from emp e group by DEPTNO) a on e2.DEPTNO = a.deptno where e2.SAL > a.avgsal) b ) delete emp from emp join (select DEPTNO,avg(sal) avgsal from emp e group by DEPTNO) e on emp.DEPTNO = e.DEPTNO where emp.SAL > e.avgsal 截断表(DDL)truncate table 表名 作用:删除表中所有数据 truncate与delete的区别 truncate属于DDL语句,它只能删除表中的所有记录，释放空间，使用rollback不可以回滚 delete属于DML语句，可以删除表中指定的记录，但不释放空间，使用rollback可以回滚 事务 事务也称作工作单元，是由一个或多个SQL语句组成的操作序列，这些SQL语句作为一个完整的工作单元，要么全部执行成功，要么全部执行失败，目的是保证数据的一致性(与业务逻辑相一致) 事务控制语言:TCL 主要用来对组成事务的DML语句的操作结果进行确认或取消，确认也就是使DML操作生效，使用commit语句，取消也就是使DML操作失效，使用rollback语句来回滚 事物的特性:ACID 原子性:事务就像原子一样，不可分割 一致性:一旦事务完成，不管是成功(提交)还是失败(回滚)，整个系统处于一致的状态 隔离性:一个事务的执行不会被另一个事务所干扰 持久性:事务一旦提交，对事务的改变是永久的，不可以再回滚 MySQL是默认是执行事务自动提交 set autocommit = 0 禁止自动提交 set autocommit = 1 自动提交(系统默认) 隐式提交: 执行了DDL语句 执行了DCL语句 隐式回滚: 客户端强制退出 客户端连到服务器端异常 系统崩溃 保存点:如果在一个事务内，想要回滚到指定位置，不是回滚到事务的起始点，可以通过保存点来实现 设置保存点:savepoint 保存点名 回滚到保存点:rollback to 保存点名 注意:回滚到保存点，事务没有结束 数据库与数据表的管理数据库的操作 创建数据库 create database [if not exists] 数据库名 [default charset uf8mb4]; 删除数据库 drop database 数据库名; 查看有哪些数据库 show databases 显示创建数据库的语句 show create database 数据库名; 切换数据库 use 数据库名; 数据表的操作 创建数据表 create table 表名( 字段名 字段类型 约束, 字段名 字段类型 约束, 字段名 字段类型 约束, ... )engine = 数据库引擎名 default charset 编码名; 数据库引擎，也称为存储引擎，MySQL中数据用各种不同的技术储存在文件中，这些技术的每一种都使用不同的存储机制，索引技巧，锁定水平等。这些不同的技术以及配套的相关功能在MySQL中被称为存储引擎。 innodb存储引擎:支持外键、事务 查看数据库支持的引擎: show engines 字段类型 整数类型 int(integer):普通大小的整数，大约是±20多亿 smallint(short):-32768到+32767 小数类型 float:单精度浮点数 double:双精度浮点数 decimal(m,n)：定点小数,m为总长,n为小数位 字符类型 char(n):定长字符类型，n为字符数，范围0~255 varchar(n):变长字符类型,n为字符数，范围1~65535 text:变长字符类型，64K 日期类型 date:日期 time:时间 datetime:日期和时间 二进制数据类型 blob:64KB 枚举类型 enum create table stu( id int, sex enum('男','女') ); insert into stu values(1,'男'); insert into stu values(2,'女'); 集合类型 set create table stu2( id int, hobby set('java','玩游戏','看书') ); insert into stu2 values(1,'java'); insert into stu2 values(2,'玩游戏'); insert into stu2 values(3,'java,看书'); select * from stu2; 约束 作用：限制每一列能写什么数据，不能写什么数据 类型 主键约束 非空约束 唯一约束 外键约束 检查约束 主键约束: primary key ,保证行的唯一性，要求唯一且非空 -- 列级定义 create table stu( id int primary key, name varchar(30) ); -- 表级定义 create table stu( id int, name varchar(30) primary key(id) ) 注意:表中可以没有主键，但建议在非特殊情况下，都要设置表的主键 一个表中只能有一个主键 一个表中可以使用多个列联合作为主键，称为联合主键，但并不推荐使用 选择没有意义的列比较合适 非空约束：not null，该列不能为空 只能是列级约束，不能是表级约束 唯一约束：unique ，保证列的唯一性 mysql中认为null是不确定值，任何两个null都是不相等的，所以在唯一约束的列上，可以有多个空值 Oracle与MySQL相同，SqlServer唯一约束列只能有一个空 create table user( id int primary key, username varchar(30) unique not null, password varchar(30) not null ); 外键约束：foreign key,保证表数据引用的完整性 constraint 外键名 foreign key (列名) references 引用表名(列名) create table class( id int primary key, name varchar(20) unique not null ); insert into class values(1,'java7'); create table stu( id int, name varchar(30), classId int, primary key(id), foreign key(classId) references class(id) ); insert into stu values(1,'Tom',1); insert into class values(2,'java8'); insert into stu values(2,'Marry',2); select * from stu; 注意:只有主键或唯一键列可以被其他表引用 check约束:对列的值进行限制 create table stu( id int primary key , name varchar(30) not null, age int , check(age >= 18) ); create table test1( id int primary key, startDate date, endDate date, check(startDate &lt;= endDate) ); 约束的位置: 列级约束：把约束写道列的定义处，例如: id int primary key 表级约束：把约束写道列的定义外，例如：id int,primary key(id) 默认值： 当不设置某列值的时候，使用的值 create table stu( id int primary key , name varchar(30) not null, age int default '18', check(age >= 18) ); 自动增长 create table stu( id int auto_increment, name varchar(30) not null, age int default '18', check(age >= 18), primary key(id) ); insert into stu(id,name) values (null,'tom') 只能在非空，主键或唯一键上添加自动增长 一个表中只能有一个自动增长列 查询最后自增长的值： select last_insert_id() 练习： 角色表(role)：id 主键 自增长 ，name 非空 唯一 用户表(user)：id 主键 自增长，username 非空 唯一，密码 默认值：888888 非空，角色编号 外键，年龄 age 不能小于18岁 修改表列的修改-- 添加列 alter table 表名 add 列名 类型 默认值; -- 修改列 alter table 表名 modify 列名 类型 默认值; -- 删除列 alter table 表名 drop 列名; 约束的添加和删除-- 添加约束 alter table 表名 add 约束; -- 删除主键 alter table 表名 drop primary key; -- 删除外键 alter table 表名 drop foreign key 外键名; -- 删除唯一约束 alter table 表名 drop index 唯一索引名(默认为列名) 删除表drop table 表名 重命名表rename table 原表名 to 新表名 复制表-- 复制表结构和数据，但是没有复制约束 create table 表名 as 子查询; -- 复制表结构，包括约束，不复制数据 create table 表名 like 原表名; 窗口函数窗口函数:在每一行上执行一个计算，这个计算涉及到从同一结果集中的其他行获取数据。这个“窗口”是通过定义在一个或多个列上的某种关系来确定的 常用的函数 rank():计算每个窗口内的行的排名 dense_rank():功能与rank类似，但不会跳过排名 row_number():给窗口内的每一行分配一个唯一的数字 案例-- 查询员工姓名,工资及工资排名 select ENAME ,SAL ,rank() over(order by sal desc) `rank` from emp ; -- 查询员工姓名，部门编号，部门内薪水排名 select e.ENAME ,d.DEPTNO , rank() over(partition by d.DEPTNO order by sal desc) `rank`, dense_rank() over(partition by d.DEPTNO order by sal desc) `dense_rank`, row_number() over(partition by d.DEPTNO order by sal desc) `row_number` from emp e join dept d on e.DEPTNO = d.DEPTNO ; limit Top N：limit N 分页: limit starindex,N starindex:从0开始的索引号 -- pageNum 第几页 pageSize:每页最多有多少行 select * from emp order by sal desc limit (pageNum-1)*pageSize,pageSize; 子句执行顺序 from、where、group by、having、select、order by、limit、union 视图在简单视图（单表，不能有分组函数、不能有group by)上可以进行增删改查的操作在复杂视图上不可以 索引的优缺点： 优点： 提高查询速度 加速排序和分组操作 可以在查询过程中使用优化隐藏 缺点 占用存储空间 影响写操作的性能 索引的维护成本 可能会带来过度优化的问题 总结 DBMS:软件，一种操作和管理数据库的大型软件 SQL：结构化的查询语言 分类： DQL:SELECT DML:数据的操作语言，insert，delete，update DDL:数据定义语言，create、drop、alter TCL:事务控制语言，commit，rollback，savepoint DCL:数据控制语言，grant，revoke 查询 where：对数据行的筛选 group by：分组 根据group by后列出的列名列表的值相同的分作一组，每组显示一行结果 分组后，select子句中只能出现分组列和分组函数 group by 后列名列表的顺序无关分组 having：对分组后的结果进行筛选 select * from emp having sal > 2000; -- mysql支持，相当于where 但不推荐使用 order by：排序 order by 列名|表达式|列号|列别名 desc降序，asc升序 多列排序：先按照前面的列排序，前面的列值相同的情况下，按照后面的列排序 limit：求topN的问题以及分页 topN:limit N 分页:limit startindex,N 表连接 等值连接和非等值连接 等值连接：表连接中使用等号 非等值连接：表连接中不使用等号 内连接和外连接 内连接：只有匹配的记录会显示出来 外连接：没有匹配的记录也会显示出来 左外连接：left join，左边表中的所有记录至少显示一次 右外连接：right join，右边表中的所有记录至少显示一次 全外连接：full join(MySQL不支持 ，可以使用union连接)，两个表中没有匹配的记录都会至少显示一次 自连接 子查询 非相关子查询：可以独立执行，不依赖于父查询 select * from emp e where sal > (select sal from emp where ename = 'smith') -- 查询各个岗位中最低薪水人的姓名，薪水(多列子查询) select ename,sal from emp e where (sal,job) in (select min(sal),job from emp group by job); 相关子查询：子查询中涉及到了父查询中的某些列，不能独立执行 在select使用: -- 不使用表连接，查询出员工的姓名和部门名称 select ename,(select dname from dept where dept.deptno = e.deptno) from emp e; 在where使用 -- 查询比部门平均工资高的员工编号、姓名、薪水、部门平均薪水 select e.EMPNO ,e.ENAME ,SAL ,(select avg(sal) from emp where e.DEPTNO = emp.DEPTNO) from emp e where e.sal > (select avg(sal) from emp where e.DEPTNO = emp.DEPTNO); 窗口函数 -- 查询员工姓名、工资和其部门平均工资，使用窗口函数不使用分组函数 select ename,sal,DEPTNO ,avg(sal) over(partition by deptno) `平均工资` from emp; DML insert insert into 表名(列名列表) values(对应的值); insert into 表名(列名列表) values(对应的值),(对应的值),(对应的值)...; insert into 表名(列名列表) 子查询; -- 创建一个新的表，结构与emp相同，表中没有数据 create table emp1 like emp; -- 把查询到的部门编号为10的所有员工插入到上述表中 insert into emp1 (select * from emp where deptno = 10); select * from emp1; update update 表名 set 列名 = 列值,列名 = 列值,列名 = 列值... [where 条件] delete delete from 表名 [where 条件] -- 删除高于本岗位平均工资的员工 delete emp from emp join (select job,avg(sal) avgsal from emp e group by job) a on emp.JOB = a.job where emp.SAL > a.avgsal; TCL：事务的控制语言 事务:把一个或多个DML语句组成一个整体，不可分割，要么全部都执行成功，要么全部都执行失败 提交:commit 回滚:rollback 设置保存点:savepoint 保存点名 回滚到保存点:rollback to 保存点名 特性：原子性，一致性，隔离性，持久性 DDL 创建数据库 create database [if not exists] 数据库名; 删除数据库 drop database 数据库名 创建表 create table 表名( 列名 数据类型 约束 默认值 自动增长, 列名 数据类型 约束 默认值 自动增长, 列名 数据类型 约束 默认值 自动增长, ... ); 删除表 drop table 表名 修改表 alter table 表名 add 列名 数据类型 约束 默认值 自动增长, modify 列名 数据类型 约束 默认值 自动增长, drop 列名, add 约束, drop primary key, drop foreign key 外键名, drop index 唯一索引名; 重命名表 rename table 原表名 新表名","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yiyecreb.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Oracle","slug":"Oracle","date":"2023-06-16T16:00:00.000Z","updated":"2023-07-20T08:53:12.762Z","comments":true,"path":"2023/06/17/Oracle/","link":"","permalink":"http://yiyecreb.top/2023/06/17/Oracle/","excerpt":"","text":"Oracle数据库 存储在一起的数据集合 能为多个用户共享 尽可能小的数据冗余 与应用程序彼此独立 数据库管理系统(DBMS) 是一种管理数据库的软件 包括数据库的创建、使用、维护、配置 数据库命令都要通过数据库管理系统处理 关系型数据库 实体以及实体间的各种关系均用关系来表示 用户的角度来看关系就是一张由行和列组成的二维数据表 常见关系型数据库 Oracle 甲骨文 MySQL 甲骨文 SQL Server 微软 DB2 IBM Sybase sybase公司 Oracle数据库简介: 目前是世界上最流行的关系型数据库之一 支持各种操作系统(Windows、Linux、IOS) 数据库领域一直处于领先地位 特点: 可移植性好 使用方便，功能强 适合各种大中小型服务器和微机环境 样例表Dept(部门) deptno:部门编号 dname:部门名称 loc:部门地址 Emp(员工表) empno:员工编号 ename:员工姓名 job:工作岗位 mgr:经历编号 hiredate:入职日期 sal:薪水 comm:奖金 deptno:部门编号 SalGrade(薪水等级表) GRADE:等级编号 LOSAL:最低工资 HISAL:最高工资 结构化的查询语言(SQL) 是操作和检索关系型数据库的标准语言 二十世纪七十年代由IBM公司开发，目前应用于各种关系型数据库 分类: 数据查询语言(DQL):SELECT，从表中查询数据 数据操作语句(DML):INSERT,UPDATE,DELETE,用于添加修改删除数据 事务处理语言(TPL):COMMIT和ROLLBACK，用于提交和回滚事务 数据控制语言(DCL):GRANT和REVOKE,用于授权和收回授权 数据定义语言(DDL):CREATE,DROP,ALTER,用于定义销毁和修改数据库对象 基本SELECT语句 SELECT语句 SELECT子句(SELECT *:查询所有列) FROM子句(FROM DEPT:表示从哪张表查询数据) SQL的相关概念 关键字:SQL语言中的保留字符串 语句:一条完整的SQL语句(独立执行) 子句:部分SQL语句(不能独立执行) 书写规则: 不区分大小写 可以在一行书写也可以多行书写，建议多行书写 关键字不可以分开，缩写或跨行写 选择列 所有列:* SELECT * FROM EMP; 选择指定列:列名之间使用逗号分隔 SELECT ENAME,HIREDATE FROM EMP; 算术运算符 +,-,*,&#x2F;,() 例题: 1.员工转正后，月薪上调20%，请查询出所有员工转正后的月薪。2.员工试用期6个月，转正后月薪上调20%，请查询出所有员工工作第一年的年薪所得（不考虑奖金部分.年薪的试用期6个月的月薪+转正后6个月的月薪) SELECT Ename,SAL,SAL*6+SAL*1.2*6 AS 试用转正年薪,SAL*1.2 AS 转正月薪 FROM EMP; 空值 空值是一种无效的,未赋值的,未知的,不确定的值 空值不同于0或空格或空字符串 包含空值的算术运算后的结果也为空值 列别名 用来在当前查询中重命名列名 书写方式 列名 列别名 列名 AS 列别名 有三种情况需要在列名两侧加上引号 列别名中包含空格 列别名中区分大小写 列别名中包含特殊字符或关键字 NVL(列名,值):空值处理函数,当列名对应的值是空的时候，返回第二个参数，不为空，返回实际值 连接操作符 用于连接列与列、列与字符 形式上为|| SELECT ENAME,JOB,ENAME||'的岗位是'||JOB FROM EMP; 原义字符串 包含在select列表中的一个字符串，一个数字或一个日期 日期和字符串字面量必须使用单引号括起来&#39;&#39;(字面量:直接写到原程序中的固定值) 每个原义字符串会在每一行都出现 SELECT ENAME,JOB,ENAME||'的岗位是'||JOB,'浑南' 公司地址,2000 年终奖金，'20-5月-2023' 日期 FROM EMP; 消除重复行:DISTINCT SELECT DISTINCT JOB FROM EMP; 练习四 1.员工试用期6个月，转正后月薪上调20%，请查询出所有员工工作第一年的所有收入（需考虑奖金部分)， 要求显示格式为:XXX的第一年总收入为XXX。 SELECT ENAME||'第一年总收入为'||((SAL+NVL(COMM,0))*6+(SAL*1.2+NVL(COMM,0))*6) FROM EMP; 2.查询员工表中一共有哪几种岗位类型。 SELECT DISTINCT JOB 岗位类型 FROM EMP; WHERE子句的使用作用 使用WHERE子句限制返回的记录 写在FROM子句后面 语法SELECT 列名列表 FROM 表名 WHERE 条件 比较运算符 &#x3D;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&lt;&gt;（不等于） 比较规则 字符串或日期类型要加上单引号 SELECT * FROM EMP WHERE ENAME = 'SMITH'; SELECT * FROM EMP WHERE HIREDATE > '20-2月-1981'; 字符串内容区分大小写 练习一: 1.查询职位为SALESMAN的员工编号、职位、入职日期。 SELECT EMPNO,JOB,HIREDATE FROM EMP WHERE JOB = 'SALESMAN'; 2.查询1985年12月31日之前入职的员工姓名及入职日期。 SELECT ENAME,HIREDATE FROM EMP WHERE HIREDATE &lt; '31-12月-1985'; 3.查询部门编号不在10部门的员工姓名、部门编号。 SELECT ENAME,DEPTNO FROM EMP WHERE DEPTNO &lt;> 10; 特殊比较运算符 between … and … 在XXX到XXX之间 SELECT * FROM EMP WHERE EMPNO BETWEEN 7800 AND 9999; IN(列表,列表) 或者 SELECT * FROM EMP WHERE DEPTNO IN(20,30); LIKE 模糊查询 &#x2F;* 使用通配符代替未知的信息 通配符:%表示任意多个字符 _表示任意一个字符 使用ESCAPE进行转义 SELECT * FROM EMP WHERE ENAME LIKE &#39;%@_%&#39; ESCAPE &#39;@&#39;; *&#x2F; SELECT * FROM EMP WHERE ENAME LIKE &#39;__O%&#39;; 练习2: 1.查询入职日期在82年至85年的员工姓名，入职日期。 SELECT ENAME,HIREDATE FROM EMP WHERE HIREDATE BETWEEN &#39;1-1月-1982&#39; AND &#39;31-12月-1985&#39;; 2.查询月薪在3000到5000的员工姓名，月薪。 SELECT ENAME,SAL FROM EMP WHERE SAL BETWEEN 3000 AND 5000; 3.查询部门编号为10或者20的员工姓名，部门编号。 SELECT ENAME,DEPTNO FROM EMP WHERE DEPTNO IN(10,20); 4.查询经理编号为7902，7566，7788的员工姓名，经理编号。 SELECT ENAME,MGR FROM EMP WHERE MGR IN(7902,7566,7788); IS NULL 判断空值 练习三: 1.查询员工姓名以W开头的员工姓名。 SELECT ENAME FROM EMP WHERE ENAME LIKE &#39;W%&#39;; 2.查询员工姓名倒数第2个字符为T的员工姓名。 SELECT ENAME FROM EMP WHERE ENAME LIKE &#39;%T_&#39;; 3.查询奖金为空的员工姓名，奖金。 SELECT ENAME,COMM FROM EMP WHERE COMM IS NULL; 逻辑运算符 AND(与):两个条件同时满足就为TRUE; OR(或):两个条件有一个满足就为TRUE; NOT(非):对指定条件取相反 练习四: 1.查询工资超过2000并且职位是MANAGER,或者职位是SALESMAN的员工姓名、职位、工资 SELECT ENAME,JOB,SAL FROM EMP WHERE SAL > 2000 AND JOB = 'MANAGER' OR JOB = 'SALESMAN' ; 2.查询工资超过2000并且职位是 MANAGER或SALESMAN的员工姓名、职位、工资。 SELECT ENAME,JOB,SAL FROM EMP WHERE (JOB = 'MANAGER' OR JOB = 'SALESMAN') AND SAL > 2000 ; 3.查询部门在10或者20，并且工资在3000到5000之间的员工姓名、部门、工资。 SELECT ENAME,DEPTNO,SAL FROM EMP WHERE DEPTNO IN(10,20) AND SAL BETWEEN 3000 AND 5000; 4.查询入职日期在81年，并且职位不是SALES开头的员工姓名、入职日期、职位。 SELECT ENAME,HIREDATE,JOB FROM EMP WHERE HIREDATE BETWEEN '1-1月-1981' AND '31-12月-1981' AND JOB NOT LIKE 'SALES%'; 5.查询职位为SALESMAN或MANAGER，部门编号为10或者20，姓名包含A的员工姓名、职位、部门编号。 SELECT ENAME,JOB,DEPTNO FROM EMP WHERE (JOB = 'MANAGER' OR JOB = 'SALESMAN') AND DEPTNO IN(10,20) AND ENAME LIKE '%A%'; 排序 作用:用来排序 语法: ORDER BY{列名|表达式|别名|列号} ASC:默认值，升序 DESC:降序 注意:空值最大(MySQL则相反) 可多列排序，先按照前面的列排序，如果前面的列值相同，使用后面的列进行排序 特殊情况: ORDER BY子句可以出现SELECT子句中没有列出的列 子句的执行顺序:FROM WHERE SELECT ORDER 表连接 为什么需要表连接 需要查询的数据分布在多张表中 什么是表连接 连接是在多张表之间通过一定的条件，使得表之间发生关联，进而能从多张表中获取数据 连接的类型 按连接条件分:等值连接，不等值连接 按其他的连接方法分:外连接和内连接 多表连接的写法： Oracle风格或旧式连接 ANSI 99(标准语法) 笛卡尔积:第一张表的所有行和第二张表的所有行都发生连接 SELECT * FROM EMP,DEPT; 等值连接 用等号连接关联的列 SELECT * FROM EMP,DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO; SELECT EMP.*,DEPT.DNAME,DEPT.LOC FROM EMP,DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO; 表连接注意 未明确定义的列:两张表中都存在的名称相同的列，解决方法:在列名前加上表名作为前缀 通常在表连接的时候，会给表起别名，目的是书写方便，一旦起了别名，在当前查询中，不能再使用原来的表名，一律使用表别名替代 非等值连接:不使用等号对表进行连接 SELECT * FROM SALGRADE S,EMP E WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL; 内连接:只有匹配的记录才会显示到最终的结果集中 SELECT * FROM EMP,DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO; SELECT 列名 FROM 表1 INNER JOIN 表2 ON 表1.列名 = 表2.列名 -- 注意:INNER可以省略 外连接:两个表连接没有匹配的记录也会显示出来，+号写在where条件中需要添加空白行的一段 主表:该表中的所有数据至少出现一次 从表:只有匹配上的记录才显示(+号写在从表一端) SELECT ENAME,EMPNO,D.DEPTNO,D.DNAME,D.LOC FROM EMP E,DEPT D WHERE E.DEPTNO(+) = D.DEPTNO; -- 左外连接 SELECT 列名 FROM 表1 LEFT OUTER JOIN 表2 ON 表1.列名 = 表2.列名; -- OUTER可以省略 -- 或者 SELECT 列名 FROM 表1,表2 WHERE 表1.列名 = 表2.列名(+); Oracle风格，表连接特点 表连接的条件和行筛选条件都写到where子句中 多于两张表的连接 SELECT ENAME,LOC,GRADE FROM EMP E,DEPT D,SALGRADE S WHERE E.DEPTNO &#x3D; D.DEPTNO AND E.SAL BETWEEN S.LOSAL AND S.HISAL; 先将两张表连接起来，再基于已经生成的连接结果(临时表)，再与第三张表连接 自连接 是一个表通过某种条件和自身进行连接的一种方式，就如同两个表连接一样 SELECT ENAME,LOC,GRADE FROM EMP E,DEPT D,SALGRADE S WHERE E.DEPTNO = D.DEPTNO AND E.SAL BETWEEN S.LOSAL AND S.HISAL; 分组函数 MAX函数:取最大值 MIN函数:取最小值 SUM函数:求和 AVG函数:求平均数 COUNT函数:查询总的记录数(空值不算):COUNT(*)指行数 DISTINCT函数:去重 GROUP BY子句 SELECT 列名 FROM 表名 WHERE 条件 GROUP BY 分组列 ORDER BY 列名; -- 多值的列和分组函数不能混用 -- GROUP BY A,B 没有先后之分，按AB相同分组 -- 分组的条件不能写在WHERE后面 -- 执行顺序:FROM WHERE GROUP SELECT ORDER -- 分组函数AVG是在GROUP期间完成的一个语句，WHERE执行分组函数时还未计算出结果 -- 解决方法如下的HAVING语句 -- 一旦分组，SELECT后只能写分组条件和分组函数(但MySQL与之不同) HAVING子句:负责分组条件的筛选 -- 标准书写顺序 SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... -- 标准执行顺序 FROM ... WHERE ... GROUP BY ... HAVING ... SELECT ... ORDER BY ... -- 注意:MYSQL中的执行顺序 FROM ... WHERE ... GROUP BY ... SELECT ... HAVING ... ORDER BY ... 子查询 括号中的查询称为子查询，外面的查询为父查询，子查询可以独立执行，先执行子查询得到确定的结果，父查询基于这些结果再执行 使用注意: 子查询用括号括起来 放在比较运算符的右边 大多数情况下，子查询不需要排序 子查询分类: 单行子查询:子查询中返回单行单列，使用的比较运算符:&gt;=、&lt;=、&gt;、&lt;、&lt;&gt;、= -- 查询比该部门平均薪水低的员工信息 SELECT * FROM EMP E JOIN (SELECT DEPTNO,AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO ) A ON E.DEPTNO &#x3D; A.DEPTNO WHERE E.SAL &lt; A.AVGSAL; 多行子查询:子查询中返回多行单列，使用的比较运算符:IN、ANY、ALL IN:和以前介绍的功能一致，判断是否与子查询的任意一个返回值相同。 -- 查询是经理的员工姓名，工资。 SELECT ENAME,SAL FROM EMP WHERE EMPNO IN( SELECT MGR FROM EMP ); ANY:表示和子查询的任意一行结果进行比较，有一个满足条件即可。 -- 查询是经理的员工姓名，工资。(ANY) SELECT ENAME,SAL FROM EMP WHERE EMPNO &#x3D; ANY( SELECT MGR FROM EMP ); -- 查询部门编号不为10，且工资比10部门任意一名工资高的员工编号，姓名，职位，工资。 SELECT EMPNO,ENAME,JOB,SAL FROM EMP WHERE DEPTNO &lt;&gt; 10 AND SAL &gt; ANY( SELECT SAL FROM EMP WHERE DEPTNO &#x3D; 10 ); ALL:表示和子查询的所有行结果进行比较，每一行必须都满足条件。 -- 查询部门编号不为10，且工资比10部门所有员工工资高的员工编号，姓名，职位，工资。 SELECT EMPNO,ENAME,JOB,SAL FROM EMP WHERE DEPTNO &lt;&gt; 10 AND SAL &gt; ALL( SELECT SAL FROM EMP WHERE DEPTNO &#x3D; 10 ); 多列子查询:子查询中返回多行多列 -- 查询各个部门收入最低的人的姓名 SELECT ENAME FROM EMP WHERE (SAL,DEPTNO) IN (SELECT MIN(SAL),DEPTNO FROM EMP GROUP BY DEPTNO); -- 1.查询职位及经理和10部门任意一个员工职位及经理相同的员工姓名，职位，不包括10部门员工 SELECT ENAME,JOB FROM EMP WHERE(JOB,MGR) IN (SELECT JOB,MGR FROM EMP WHERE DEPTNO &#x3D; 10) AND DEPTNO &lt;&gt; 10; -- 2.查询职位及经理和10部门任意一个员工职位或经理相同的员工姓名，职位，不包括10部门员工 SELECT ENAME,JOB FROM EMP WHERE (JOB IN (SELECT JOB FROM EMP WHERE DEPTNO &#x3D; 10) OR MGR IN (SELECT MGR FROM EMP WHERE DEPTNO &#x3D; 10)) AND DEPTNO &lt;&gt; 10; 注意:如果子查询中有空值，就不能使用NOT IN运算符 ROWNUM ROWNUM是一个伪列，伪列是使用上类似于表中的列而实际没有存储在表中的特殊对象 ROWNUM的功能是在每次查询时返回结果集的顺序数，这个顺序数是在记录输出时才一步一步产生的，第一行显示1，第二行显示2，以此类推 ROWNUM只能进行小于和小于等于的运算，不能执行大于或大于等于运算 TOP-N 是实现表中按照某个列排序输出最大或最小的N条记录 SELECT ROWNUM,A.ENAME FROM (SELECT ENAME FROM EMP ORDER BY SAL DESC) A WHERE ROWNUM &lt; 3; 分页 pagesize 每页的记录数(每页最多有多少行) pagenum 目标页数(第几页) -- 1.按照每页显示5条记录，分别查询工资最高的第1页，第2页，第3页信息，要求显示员工姓名、入职日期、部门名称、工资。 SELECT B.ENAME 姓名, B.HIREDATE 入职日期, DNAME 部门名称, B.SAL 工资 FROM (SELECT A.*, ROWNUM NM FROM (SELECT * FROM EMP ORDER BY SAL DESC) A WHERE ROWNUM &lt;&#x3D; 5) B JOIN DEPT D ON B.DEPTNO &#x3D; D.DEPTNO WHERE NM &gt;&#x3D; 1; SELECT B.ENAME 姓名, B.HIREDATE 入职日期, DNAME 部门名称, B.SAL 工资 FROM (SELECT A.*, ROWNUM NM FROM (SELECT * FROM EMP ORDER BY SAL DESC) A WHERE ROWNUM &lt;&#x3D; 10) B JOIN DEPT D ON B.DEPTNO &#x3D; D.DEPTNO WHERE NM &gt;&#x3D; 6; SELECT B.ENAME 姓名, B.HIREDATE 入职日期, DNAME 部门名称, B.SAL 工资 FROM (SELECT A.*, ROWNUM NM FROM (SELECT * FROM EMP ORDER BY SAL DESC) A WHERE ROWNUM &lt;&#x3D; 15) B JOIN DEPT D ON B.DEPTNO &#x3D; D.DEPTNO WHERE NM &gt;&#x3D; 11; 相关子查询 当子查询中引用的父查询表中的一个列时,Oracle服务器执行相关子查询 执行过程: 取得父查询的候选行 用候选行被子查询引用列的值执行子查询 用来自子查询的值确认或取消候选行 重复上面三步直到父查询中没有剩余的候选行为止 相关子查询不可以独立执行 -- 查询工资高于部门平均薪水的员工信息 SELECT * FROM EMP E WHERE SAL &gt; (SELECT AVG(SAL) FROM EMP WHERE DEPTNO &#x3D; E.DEPTNO); EXISTS:判断是否存在,操作过程: 子查询如果有记录找到，子查询语句不会继续执行，返回值为true 子查询中如果到表的末尾也没找到，返回false -- 查询是经理的员工姓名 SELECT ENAME FROM EMP E WHERE EXISTS(SELECT (&#39;1&#39;) FROM EMP WHERE E.EMPNO &#x3D; MGR ); NOT EXISTS:与上面相反，判断子查询是否没有返回值，如果没有返回值，表达式为true，如果找到一条返回值，则为false -- 查询不是经理的员工姓名 SELECT ENAME FROM EMP E WHERE NOT EXISTS(SELECT (&#39;1&#39;) FROM EMP WHERE E.EMPNO &#x3D; MGR );","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yiyecreb.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"2023年两天一夜的大连旅游记录","slug":"0613大连旅游记录","date":"2023-06-13T14:48:42.889Z","updated":"2023-07-20T08:53:03.862Z","comments":true,"path":"2023/06/13/0613大连旅游记录/","link":"","permalink":"http://yiyecreb.top/2023/06/13/0613%E5%A4%A7%E8%BF%9E%E6%97%85%E6%B8%B8%E8%AE%B0%E5%BD%95/","excerpt":"","text":"2023年6月12日:老虎滩海洋主题公园浏览","categories":[{"name":"日常","slug":"日常","permalink":"http://yiyecreb.top/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常分享","slug":"日常分享","permalink":"http://yiyecreb.top/tags/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB/"}]},{"title":"若依管理系统学习使用经验(佛系更新中)","slug":"若依管理系统开发学习经验","date":"2023-06-03T06:46:33.592Z","updated":"2023-07-20T08:53:29.319Z","comments":true,"path":"2023/06/03/若依管理系统开发学习经验/","link":"","permalink":"http://yiyecreb.top/2023/06/03/%E8%8B%A5%E4%BE%9D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/","excerpt":"","text":"话说在前 本文章仅用来共享我个人使用时遇见的问题以及自己在使用中学会的一些使用方式 什么是若依:若依是一套全部开源的快速开发平台(可以参考人人开源)，便于实现各种管理系统的快速开发 环境配置 MySQL &gt;&#x3D; 5.7 JDK &gt;&#x3D; 1.8 Maven &gt;&#x3D; 3.0 Redis(我个人使用的是5.0.14.1) NodeJS 运行软件:IDEA(当然eclipse也是可以的) 若依官网:ruoyi.vip 若依Gitee源码仓库:RuoYi-Vue: 🎉 基于SpringBoot，Spring Security，JWT，Vue &amp; Element 的前后端分离权限管理系统，同时提供了 Vue3 的版本 (gitee.com) 运行将从gitee上下载好的若依项目使用IDEA或eclipse打开，等待maven根据pom文件下载框架依赖以及jar包 连接数据库:建立一个名为ry的数据库(当然,起别的名字也可以,但要注意在配置文件内改变默认的数据库名称),在数据库内运行文件内自带的两个sql文件 修改数据库连接:编辑resources目录下的application-druid.yml url为数据库地址,username为数据库账号,password为数据库密码 修改服务器配置编辑resources目录下的application.yml port为端口号 在运行软件内开始运行显示: (♥◠‿◠)ﾉﾞ 若依启动成功 ლ(´ڡ&#96;ლ)ﾞ .-------. ____ __ | _ _ \\ \\ \\ &#x2F; &#x2F; | ( &#39; ) | \\ _. &#x2F; &#39; |(_ o _) &#x2F; _( )_ .&#39; | (_,_).&#39; __ ___(_ o _)&#39; | |\\ \\ | || |(_,_)&#39; | | \\ &#96;&#39; &#x2F;| &#96;-&#39; &#x2F; | | \\ &#x2F; \\ &#x2F; &#39;&#39;-&#39; &#96;&#39;-&#39; &#96;-..-&#39; 即为运行成功 无法启动的一些常见原因:1.Redis未启动或Redis本身设有密码(启动redis或者把密码配置好就行) 2.数据库未连接 前端运行找到ruoyi-ui文件夹,在ruoyi-ui内打开控制台,输入npm install下载依赖,再输入npm run dev运行前端VUE项目(PS:端口号在vue-config.js文件内修改) 运行成功后在浏览器内输入localhost:80(默认端口),即可进入登录页面 关于验证码的问题；如果登录界面没有验证码图片内容，说明后端端口没连接上或后端没运行,将后端代码运行或连接端口就可以解决(所以说没事别乱改默认端口,后面有苦给你吃哦) 更新内容至此，下次更新随缘","categories":[{"name":"学习经验","slug":"学习经验","permalink":"http://yiyecreb.top/categories/%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"五月二十八号的散步心得","slug":"0528","date":"2023-05-28T13:57:26.898Z","updated":"2023-07-20T08:53:43.333Z","comments":true,"path":"2023/05/28/0528/","link":"","permalink":"http://yiyecreb.top/2023/05/28/0528/","excerpt":"","text":"近些天因为大大小小的各种事情加生活琐碎还有夏天的闷热真的导致心情很难蚌，多少有点控制不了自己的情绪，和女朋友一起在学校里散步真的解决了很多问题，至少有了缓解的依靠，真的蛮幸运的(话说以后这博客不会大部分都是我的碎碎念和日常吧[划去])","categories":[{"name":"日常","slug":"日常","permalink":"http://yiyecreb.top/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常分享","slug":"日常分享","permalink":"http://yiyecreb.top/tags/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB/"}]},{"title":"欢迎来到依夜的个人博客","slug":"我的第一个笔记","date":"2023-05-24T05:25:42.972Z","updated":"2023-07-20T08:53:16.496Z","comments":true,"path":"2023/05/24/我的第一个笔记/","link":"","permalink":"http://yiyecreb.top/2023/05/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AC%94%E8%AE%B0/","excerpt":"","text":"欢迎来到依夜的博客 从2023年5月27日起本博客正式开始投入，我的博客一般会发一些我的学习笔记，生活趣事分享以及一些观影观番游戏体验感谢，也愿意与更多的网络朋友们建议友情链接交流技术和爱好","categories":[{"name":"日常","slug":"日常","permalink":"http://yiyecreb.top/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常分享","slug":"日常分享","permalink":"http://yiyecreb.top/tags/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB/"}]}],"categories":[{"name":"数据库","slug":"数据库","permalink":"http://yiyecreb.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Git","slug":"Git","permalink":"http://yiyecreb.top/categories/Git/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yiyecreb.top/categories/JavaWeb/"},{"name":"VUE","slug":"VUE","permalink":"http://yiyecreb.top/categories/VUE/"},{"name":"H5&CSS3","slug":"H5-CSS3","permalink":"http://yiyecreb.top/categories/H5-CSS3/"},{"name":"Java","slug":"Java","permalink":"http://yiyecreb.top/categories/Java/"},{"name":"框架","slug":"框架","permalink":"http://yiyecreb.top/categories/%E6%A1%86%E6%9E%B6/"},{"name":"算法","slug":"算法","permalink":"http://yiyecreb.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"DOS","slug":"DOS","permalink":"http://yiyecreb.top/categories/DOS/"},{"name":"日常","slug":"日常","permalink":"http://yiyecreb.top/categories/%E6%97%A5%E5%B8%B8/"},{"name":"学习经验","slug":"学习经验","permalink":"http://yiyecreb.top/categories/%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"日常分享","slug":"日常分享","permalink":"http://yiyecreb.top/tags/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB/"}]}