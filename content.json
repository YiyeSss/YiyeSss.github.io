{"meta":{"title":"依夜の妙妙屋","subtitle":"Here is YiyeSss","description":"","author":"依夜","url":"http://yiyecreb.top","root":"/"},"pages":[{"title":"关于我","date":"2023-05-24T09:04:19.000Z","updated":"2023-06-17T07:40:00.983Z","comments":true,"path":"about/index.html","permalink":"http://yiyecreb.top/about/index.html","excerpt":"","text":"欢迎来到我的博客 My Friends , Welcome to my blog I hope you can have a happy day after reading this 语言 C Java H5,CSS3,JS VUE2 账号 网站 账号 昵称 Gitee YiyeSss 依夜 洛谷 YiyeSss YiyeSss"},{"title":"分类","date":"2023-05-24T08:17:10.000Z","updated":"2023-05-24T08:21:53.840Z","comments":true,"path":"categories/index.html","permalink":"http://yiyecreb.top/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-07-26T01:06:54.746Z","updated":"2023-07-26T01:06:54.746Z","comments":true,"path":"friend/index.html","permalink":"http://yiyecreb.top/friend/index.html","excerpt":"","text":"本博客信息 站名： 依夜の小窝 站长： 依夜 地址： https://yiyecreb.top/ 备用地址：https://YiyeSss.github.io/ 申请方法 添加本站后，在本页留言，格式如下 ```yml - name: #您的名字 url: #您的网址 desc: #简短描述 image: #一张图片 ``` 依夜和他的动物朋友们 单天琦 室友，一代大神 金铉杰 室友，一代大神 许帅帅 同学，一代大神 尹寒康 同学，一代大神"},{"title":"标签","date":"2023-05-24T08:19:20.000Z","updated":"2023-05-24T08:22:40.116Z","comments":true,"path":"tags/index.html","permalink":"http://yiyecreb.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java","slug":"JavaSE","date":"2023-07-25T16:00:00.000Z","updated":"2023-07-27T07:59:26.899Z","comments":true,"path":"2023/07/26/JavaSE/","link":"","permalink":"http://yiyecreb.top/2023/07/26/JavaSE/","excerpt":"","text":"Java概述 java特点:跨平台性，一次编译，到处运行 Java的加载与执行： 编程语言： 机器语言：使用机器指令编程 汇编语言：通过大量英文单词来代表计算机指令 高级语言：C、Python、Java、C++、php、C#、JS 编译：把其他语言编程的程序转换为机器指令 虚拟机：虚拟的操作系统,模仿真实的计算机 语言版本 1990年 Sun公司开始研发，创始人：詹姆斯-高斯林 2009年 Oracle收购 2014年 Java8 2022年10月 Java19 版本 JavaSE：java标准版，编写控制台，Windows程序 JavaEE：java企业版，web应用(淘宝、京东) JavaME：java微缩版，用于嵌入式设备 环境搭建： JDK：Java开发工具包 bin：存放了很多命令 java.exe:运行Java程序 javac.exe:编译源程序，生成字节码文件 javadoc.exe:生成文档 JRE：Java运行时的环境 环境变量的配置 JAVA_HOME:指出jdk的安装目录 path：查找命令而设立的，%JAVA_HOME%\\bin 集成开发环境 Eclipse IntelliJ Idea 注释 作用： 对已有代码添加注释，是对代码的解释说明，便于阅读和理解 暂时不想执行的代码先注释掉，需要的时候再打开注释 生成文档 注释的种类 单行注释：以两个正斜线//开头，只是对当前行内容注释掉，对下一行不起作用，快捷键Ctrl + / 多行注释：注释多行代码，以/*开头，以*/结尾，多行注释不能嵌套，快捷键Ctrl+Shift+/ 文档注释：/**文档注释内容*/，使用java文档工具(JavaDoc)，可以提取出这些注释内容，生成帮助文件或显示在代码提示中 在Idea中，工具 &#x3D;&gt; 生成JavaDoc 默认使用gbk编码，如果想生成UTF-8编码的文档，在生成界面中修改：命令行实参:-encoding utf-8 变量和运算符变量 变量:代表着内存中的一段空间，用来存储可能变化的数据 变量的声明 变量类型 变量名 [&#x3D; 变量的初始值]; int n; n = 5000; int n = 5000;//声明的同时进行初始化 注意: 局部变量(方法中定义的变量)，没有默认值 变量必须先声明再使用 变量的作用： 输出变量的值 使用变量参与运算 变量的作用域(在哪个范围内可以使用) 从定义处开始到当前定义的代码块结束的大括号为止 在一个作用域中不能有重名的变量名 标识符： 定义：Java中的类、包、方法、变量等的名称称为标识符。 命名规则： 必须以字母、下划线(_)或美元符号($)开头 其余的字符可以是字母、下划线、美元符号或数字(长度不限) 标识符中不能有空格 不能使用Java的关键字和保留字 关键字：事先定义好的对编译有特殊意义的单词 class,int 保留字：Java语法中暂时没有使用到该单词，但是保留起来，以后可能会使用 goto 数据类型 Java中数据类型分为两大类 基本数据类型：int等 引用类型：class 基本数据类型： 整数类型： byte：字节，1byte &#x3D; 8bit、从-128到127 short：短整数，2个字节，16bit，-32768到32767 short s1 = Short.MAX_VALUE; System.out.println(s1); short s1 = Short.MIN_VALUE; System.out.println(s2); int：整数型，4个字节，32bit,正负21亿多 long：长整数，8个字节，64bit，共19十进制位，后缀：L 进制：一种表示数字的方法，也称为基数或基数系统。常用：二进制、八进制、十进制、十六进制 二进制以二为基数，使用0和1来表示数值，10表示2，以0b为前缀 八进制以八为基数，使用0到7来表示数值，10表示8，以0为前缀 十六进制以十六为基数，使用0到9,A到F来表示数值，10表示16，以0x或0X为前缀 进制转换 其他进制字符串转换10进制整数 Integer.parseInt(10,进制数) 例如: Integer.parseInt(10,2) //把二进制10转换为十进制整数 把十进制的整数转换为其他进制的字符串 String binaryString = Integer.toBinaryString(10);//转2 System.out.println(binaryString); String octalString =Integer.toOctalString(10);//转8 System.out.println(octalString); String hexString =Integer.toHexString(10);//转16 System.out.println(hexString); 浮点数：近似小数，可以表示很大范围的数值，但精度(有效位数)有限 float:单精度浮点数，4字节存储，32bit，有效位数:6~7位，后缀L double:双精度浮点数，8字节，64bit，有效位数约为15位，后缀D float f1 = 3.14f或3.14f double f1 = 3.14 字符类 char：2个字节，16bit无符号整数，单引号括&#39;&#39;起来的一个字符 使用Unicode编码，能够保存世界上主要语言的主要字符 Unicode常用分类：utf-8，utf-16，utf-32，Java中用的是utf-16 在java中，可以使用\\u后面跟着4个十六进制的数字的unicode来表示一个字符 char c2 = '\\u4e2d';//中 特殊字符 \\t：制表符 \\n：换行符 \\r：回车 布尔类型： boolean：适合表示比较和逻辑运算的结果，值：true/false 10 &gt; 20 数据类型的转换: 不同数据类型不能直接进行运算，需要先转换为相同类型再运算 有两种转换的方法 自动转换：也称为隐式转换，由取值范围小的向取值范围大的转换 强制类型转换: 由取值方位大的向取值范围小的转换，系统不能自动进行 (int)3.14 (数据类型)值 当byte、short、char参与运算的时候，会先把它们的数据类型转换为int，再运算 byte b1 = 10; byte b2 = 20; int result = b1 + b2; 字面量; 直接写入程序的量 float:3.14F double:3.14D long:1000L 运算符 定义：也称为操作符，是一种特殊的符号，用来表示数值的运算、赋值和比较 赋值运算符 =：把=右边的值赋值给=左边的变量或常量 复合运算符 +=：把变量的值取出来，进行加法运算，然后再把运行的结果放回变量中 -=：把变量的值取出来，进行减法运算，然后再把运行的结果放回变量中 /=：把变量的值取出来，进行除法运算，然后再把运行的结果放回变量中 *=：把变量的值取出来，进行乘法运算，然后再把运行的结果放回变量中 %=：把变量的值取出来，进行取余运算，然后再把运行的结果放回变量中 算术运算符 二元运算符：+ - * / % 一元运算符：++、-- ++：自增 ++变量：前自增 可以理解执行顺序为 int n = 2; int n = n + 1; int k = n//k可以拟为++n的表达式 变量++：后自增 可以理解执行顺序为 int n = 2; int k = n//k可以拟为n++的表达式 int n = n + 1; --：自减 –变量：前自减 可以理解执行顺序为 int n = 2; int n = n - 1; int k = n//k可以拟为--n的表达式 变量–：后自减 可以理解执行顺序为 int n = 2; int k = n//k可以拟为n--的表达式 int n = n - 1; 表达式： 定义：是符合一定语法规则的运算符和运算数的序列 表达式的值：表达式中操作数进行运算得到的结果称为表达式的值，任何表达式都有一个值 表达式的数据类型：表达式的值的类型就是表达式的数据类型 比较运算符(关系运算符)，用来对数值进行比较，表达式的结果为布尔值 ==：比较两个数是否相等 !=：不等于 &gt;：大于 &lt;：小于 &gt;=：大于等于 &lt;=：小于等于 逻辑运算符：对布尔类型进行运算 &amp;&amp;：与运算符(短路与),两边的布尔类型值同时为true，则整个表达式的值为true，否则为false 当左边的表达式的结果为false的时候，就不进行右边表达式的计算了，这种效果称为短路 如果希望运行后面的表达式，只写一个&amp;(与) ||：或运算符(短路或),两边的布尔类型值同时为false，则整个表达式的值为false，否则为true 当左边的表达式的结果为true的时候，就不进行右边表达式的计算了，这种效果称为短路 如果希望运行后面的表达式，只写一个|(或) !：非，一元运算符，对布尔值取相反的结果 三元表达式 语法：表达式1?表达式2:表达式3; 表达式1的值为布尔类型，如果为true，整个表达式的值为表达式2的值，如果为false，整个表达式的值为表达式3的值 运算符的优先级 按照操作数来划分：一元操作符 &gt; 二元操作符 &gt; 三元操作符 按运算符的类型来划分：算数运算符 &gt; 比较(关系)运算符 &gt; 逻辑运算符 &gt; 赋值运算符 运算符 优先级 类型转换 11&#x2F;&#x2F;数越大优先级越高 ++、– 10 ! 9 *、&#x2F;、% 8 +、- 7 &gt;、&gt;&#x3D;、&lt;、&lt;&#x3D; 6 &#x3D;&#x3D;、!&#x3D; 5 &amp; 4 | 3 &amp;&amp; 2 || 1 &#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D; 0 控制台读取数据Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); System.out.println(n); String z = scanner.nextInt();//读到字符串到空格结束 System.out.println(z); String y = scanner.nextLine();//读到字符串到换行结束 System.out.println(y) double x = scanner.nextDouble(); System.out.println(x); 流程控制语句条件控制语句if语句语法1： if(条件)&#123; 语句块 &#125; 如果条件为true，就执行大括号中的语句块，如果为false，该if语句直接结束 语法2：二选一 if(条件)&#123; 语句块1 &#125;else&#123; 语句块2 &#125; 如果条件为true，就执行语句块1，如果为false，就执行语句块2 语法3：多选一 if(条件1)&#123; 代码块1 &#125;else if(条件2)&#123; 代码块2 &#125;else if(条件3)&#123; 代码块3 &#125;...else&#123; 代码块n &#125; 语法4：嵌套 if(条件1)&#123; 代码块1 &#125;else&#123; if(条件2)&#123; 代码块2 &#125;else &#123; 代码块 &#125; &#125; switch语句语法: switch(表达式)&#123; case 值1: 语句块 [break]; case 值2: 语句块 [break]; ... default: 语句块 &#125; 执行过程： 计算switch后表达式的值 把该值与case后的值进行比较，如果找到相等的，则运行该case后的语句块，而不管后面的case条件是否满足，直到碰到break语句或结束switch语句的&#125;为止 注意： 表达式的值只能接收int,byte,short,char,Sring类型，不支持其他类型 不允许有重复的case取值 只能进行等值运算 case之间以及default没有顺序，先判断case，再执行default 如果default在写case前面，又没有在default语句中使用break，依然会有向下贯穿的执行效果 循环控制语句While语句语句: while(条件表达式)&#123; 循环体(语句块) &#125; 执行过程： 计算条件表达式的值，如果该表达式的值为true，执行该循环体中的语句块 然后再判断表达式的值是否为true，如果为true，再执行循环体语句，直到值为false为止 break：退出当前循环do…while语句： do&#123; 循环体语句 &#125;while(条件); 执行过程： 先执行循环体内的语句块，然后再判断条件是否为true，如果为true，再次执行循环体，如果为false，则退出循环 与while的区别：do...while循环至少会执行一次，while可能一次都不执行 for语句： for(初始化表达式;循环条件表达式;循环后表达式)&#123; 循环体语句 &#125; 执行过程： 先执行初始化表达式，在整个循环过程中，该表达式只执行一次 执行循环条件表达式，如果该表达式的值为true，执行循环体语句块，然后执行循环体后表达式 再判断循环条件表达式的值是否为true，如果为true，继续执行循环，若为false，退出循环 注意： 在初始化表达式中，可以定义多个类型相同的变量，直接用,分隔开 continue作用：跳过本次循环的剩余语句，执行下一次循环 嵌套循环 定义：在循环体中包含另一个循环，称为嵌套循环 循环体内称为内循环，外面的循环称为外循环 执行过程： 外循环执行一次，内循环执行一遍 数组 定义：数组可以看成是多个相同的数据类型的数据组合，目的是实现对这些数据的统一管理 数组元素：数组中的每一个数据，称为数组的一个元素，数组中的元素可以是任意类型 数组的长度：数组中元素的个数，数组一旦创建，数组的长度就不能再改变(数组名.length) 数组的声明 数据类型[] 变量名; 数据类型 变量名[];&#x2F;&#x2F;极不推荐 数组的创建 new 数据类型[数组的长度]; 数组创建后，基本数据类型的元素的默认值为0(boolean:false,char:&#39;\\u0000&#39;)，引用类型元素的默认值为null; 数组的初始化：数组创建的时候，直接指定元素的值 动态初始化：使用new关键字初始化 int[] scores = new int[](45,67,89); int[] scores; scores = new int[](45,67,89); 静态初始化：不使用new关键字进行初始化 int[] scores = &#123;45,67,89&#125;;//只能在声明的同时进行静态初始化 数组的访问： 数组使用下标来访问元素，下标(索引号)从0开始 语法： 数组名[下标&#x2F;索引号] 数组的第一个元素：数组名[0] 数组的最后一个元素：数组名[数组名.length - 1] 注意：数组越界异常：java.lang.ArrayIndexOutOfBoundsException 为数组元素赋值：数组[下标] &#x3D; 值 foreach语句(语法糖)：遍历数组的所有元素 for(数组元素的数据类型 变量名 : 数组名)&#123; 循环体语句块 &#125; Arrays：该类是数组工具类，包含了数组的一些常见操作，比如排序 Arrays.sort(数组名),对数组中的元素进行升序排序 Arrays.toString(数组名),该方法能够以制定的格式返回数组中每一个元素连接成的字符串 Arrays.copyOf(原数组,新数组的长度)：返回新创建的数组长度是指定的，并拷贝原数组中的元素到新数组中 int[] arr = &#123;5,2,10,8,4,5&#125;; Arrays.sort(arr); for (int ele :arr)&#123; System.out.println(ele); &#125; for (int i = arr.length-1;i >=0 ; i--)&#123; System.out.println(arr[i]); &#125; int[] arr2 = Arrays.copyOf(arr,10); System.out.println(Arrays.toString(arr2)); System.out.println( Arrays.toString(arr)); 程序调试 作用： 查看程序执行过程 查看内存数据的变化情况 查找程序逻辑错误 步骤 设置断点 进入Debug模式 运行停止在断点处(当前代码没有执行) 步过(执行当前行代码) Idea快捷键：F8 恢复程序(执行到下一个断点处，如果没有下一个断点，程序执行到结束) Idea快捷键：F9 停止(直接停止程序调试) Idea快捷键：Ctrl+F2 使用评估窗口：计算表达式的值","categories":[{"name":"Java","slug":"Java","permalink":"http://yiyecreb.top/categories/Java/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"高精度算法","slug":"高精度算法","date":"2023-07-23T16:00:00.000Z","updated":"2023-07-24T12:09:56.915Z","comments":true,"path":"2023/07/24/高精度算法/","link":"","permalink":"http://yiyecreb.top/2023/07/24/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95/","excerpt":"","text":"高精度算法高精度加法//1.输入两个整数a,b，输出他们的和(a,b≤10^9) //2.输入两个整数a,b，输出他们的和(a,b≤10^500) /*分析:int : -2^31~2^31-1，数量级为10^9 long long:-2^63~2^63-1,数量级为10^18 解决方法：用数组模拟高精度*/ 算法核心： c[i] +&#x3D; a[i] + b[i]; c[i+1] &#x3D; c[i] &#x2F; 10; c[i] &#x3D; c[i] % 10; //1.字符串读入 //2.字符串转数组 //3.竖式加法 //4.消前导零 //5.倒序输出 Java的高精度加法import java.math.BigInteger; import java.util.Scanner; public class HighPrecisionAdd &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); String x = scanner.nextLine(); String y = scanner.nextLine(); BigInteger bigx = new BigInteger(x); BigInteger bigy = new BigInteger(y); BigInteger sum = bigx.add(bigy); System.out.println(\"和为\"+sum); &#125; &#125; C++的高精度加法#include &lt;bits&#x2F;stdc++.h&gt; using namespace std; string x,y; int a[10000],b[10000],c[10000],la,lb,lc; int main()&#123; cin &gt;&gt; x &gt;&gt; y; la &#x3D; x.length(); lb &#x3D; y.length(); for(int i &#x3D; 0; i &lt; la ; i++)&#123; a[la-i] &#x3D; x[i] - &#39;0&#39;; &#125; for(int i &#x3D; 0; i &lt; la ; i++)&#123; b[lb-i] &#x3D; y[i] - &#39;0&#39;; &#125; lac &#x3D; max(la,lb); for(int i &#x3D; 1; i &lt;&#x3D; lc ; i++)&#123; c[i] +&#x3D; a[i] + b[i]; c[i+1] &#x3D; c[i] &#x2F; 10; c[i] %&#x3D; 10; &#125; if(c[lc+1] &gt; 0)lc++; for(int i &#x3D; lc ; i &gt;&#x3D; 1 ; i--) count &lt;&lt; c[i]; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yiyecreb.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"常见的DOS命令","slug":"DOS","date":"2023-07-22T16:00:00.000Z","updated":"2023-07-23T03:28:44.309Z","comments":true,"path":"2023/07/23/DOS/","link":"","permalink":"http://yiyecreb.top/2023/07/23/DOS/","excerpt":"","text":"常见的DOS命令 exit：退出当前DOS命令窗口 cls：清屏 DOS窗口中的内容复制：在DOS窗口的任意位置点击鼠标右键，点击标记，选择要复制的内容，在任意位置点击右键，在需要粘贴的位置粘贴即可（我的评价是不如CV） dir：列出当前目录下的所有子文件&#x2F;子目录 cd命令：change directory【改变目录】 cd命令用法： cd目录的路径：包括绝对路径和相对路径 绝对路径:表示该路径从某个磁盘的盘符下作为出发点的路径 相对路径:表示该路径从当前所在的路径下作为出发点的路径 假设当前所在的路径是C:\\Users \\Administrator,那么在此时输入cd Desktop,那么其中Desktop就是一个相对路径，从当前所在的C:\\Users\\Administrator这个路径作为出发点,开始找Desktop目录。 假设是这样写的:cd C:\\Users\\Administrator\\Desktop,其中C:\\Users\\Administrator\\Desktop路径就是一个绝对路径。 cd .. 回到上级目录 cd \\ 直接回到根目录 切换盘符： c: d: e: f:","categories":[{"name":"DOS","slug":"DOS","permalink":"http://yiyecreb.top/categories/DOS/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"MySQL","slug":"MySql","date":"2023-07-17T16:00:00.000Z","updated":"2023-07-21T06:59:43.789Z","comments":true,"path":"2023/07/18/MySql/","link":"","permalink":"http://yiyecreb.top/2023/07/18/MySql/","excerpt":"","text":"MySQL表连接 全外连接:MySQL不支持,使用union来解决 union是MySQL中用来组合两个或多个select语句的结果集的一个操作符 基本语法: SELECT COLUMN_NAME(S) FROM TABLE1 UNION SELECT COLUMN_NAME(S) FROM TABLE2 使用规则: union内的每个select语句必须拥有相同数量的列，并且对应列也拥有兼容的数据类型 union会去掉重复行 如果不想去掉重复行：使用union all SQL DQL:数据查询语言:select DML:数据操作语言,insert,update,delete DDL:数据定义语言:create,alter,drop DCL:数据控制语言:grant,remoke TPL:事务控制语言,commit,rollback,savepoint DML插入语句语法: insert into 表名 (列名列表) values (对应值的列表) 列名列表可以省略，对应值输入的顺序与表的设计顺序一致，而且每列都要插入值 插入空值 列名列表中不写值为空的列 值设置为空(null) 一次插入多行记录 insert into 表名(列名列表) values (对应的列表),(对应的列表),(对应的列表)... insert into 表名(列名列表) 子查询; insert into emp_copy select * from emp where DEPTNO = 10; 快速创建表(DDL)create table 表名 as 子查询; create table emp_copy as select * from emp where 1 &lt;> 1; 更新语句语法: update 表名 set 列名 = 值,列名 = 值,列名 = 值,列名 = 值,列名 = 值,列名 = 值... [where 条件] 例题: -- 把员工的工资改为其部门的平均薪水 update emp e1,(select DEPTNO,avg(sal) avgsal from emp group by DEPTNO ) e2 set e1.SAL = e2.avgsal where e1.DEPTNO = e2.deptno; update emp e1 join (select DEPTNO,avg(sal) avgsal from emp group by DEPTNO ) e2 on e1 .DEPTNO = e2.DEPTNO set e1.SAL = e2.avgsal; 删除语句语法: delete from 表名 [where 条件] 例题: -- 3.删除工资大于所在部门平均工资的员工记录 delete from emp where EMPNO in (select EMPNO from (select e2.EMPNO from emp e2 join (select DEPTNO,avg(sal) avgsal from emp e group by DEPTNO) a on e2.DEPTNO = a.deptno where e2.SAL > a.avgsal) b ) delete emp from emp join (select DEPTNO,avg(sal) avgsal from emp e group by DEPTNO) e on emp.DEPTNO = e.DEPTNO where emp.SAL > e.avgsal 截断表(DDL)truncate table 表名 作用:删除表中所有数据 truncate与delete的区别 truncate属于DDL语句,它只能删除表中的所有记录，释放空间，使用rollback不可以回滚 delete属于DML语句，可以删除表中指定的记录，但不释放空间，使用rollback可以回滚 事务 事务也称作工作单元，是由一个或多个SQL语句组成的操作序列，这些SQL语句作为一个完整的工作单元，要么全部执行成功，要么全部执行失败，目的是保证数据的一致性(与业务逻辑相一致) 事务控制语言:TCL 主要用来对组成事务的DML语句的操作结果进行确认或取消，确认也就是使DML操作生效，使用commit语句，取消也就是使DML操作失效，使用rollback语句来回滚 事物的特性:ACID 原子性:事务就像原子一样，不可分割 一致性:一旦事务完成，不管是成功(提交)还是失败(回滚)，整个系统处于一致的状态 隔离性:一个事务的执行不会被另一个事务所干扰 持久性:事务一旦提交，对事务的改变是永久的，不可以再回滚 MySQL是默认是执行事务自动提交 set autocommit = 0 禁止自动提交 set autocommit = 1 自动提交(系统默认) 隐式提交: 执行了DDL语句 执行了DCL语句 隐式回滚: 客户端强制退出 客户端连到服务器端异常 系统崩溃 保存点:如果在一个事务内，想要回滚到指定位置，不是回滚到事务的起始点，可以通过保存点来实现 设置保存点:savepoint 保存点名 回滚到保存点:rollback to 保存点名 注意:回滚到保存点，事务没有结束 数据库与数据表的管理数据库的操作 创建数据库 create database [if not exists] 数据库名 [default charset uf8mb4]; 删除数据库 drop database 数据库名; 查看有哪些数据库 show databases 显示创建数据库的语句 show create database 数据库名; 切换数据库 use 数据库名; 数据表的操作 创建数据表 create table 表名( 字段名 字段类型 约束, 字段名 字段类型 约束, 字段名 字段类型 约束, ... )engine = 数据库引擎名 default charset 编码名; 数据库引擎，也称为存储引擎，MySQL中数据用各种不同的技术储存在文件中，这些技术的每一种都使用不同的存储机制，索引技巧，锁定水平等。这些不同的技术以及配套的相关功能在MySQL中被称为存储引擎。 innodb存储引擎:支持外键、事务 查看数据库支持的引擎: show engines 字段类型 整数类型 int(integer):普通大小的整数，大约是±20多亿 smallint(short):-32768到+32767 小数类型 float:单精度浮点数 double:双精度浮点数 decimal(m,n)：定点小数,m为总长,n为小数位 字符类型 char(n):定长字符类型，n为字符数，范围0~255 varchar(n):变长字符类型,n为字符数，范围1~65535 text:变长字符类型，64K 日期类型 date:日期 time:时间 datetime:日期和时间 二进制数据类型 blob:64KB 枚举类型 enum create table stu( id int, sex enum('男','女') ); insert into stu values(1,'男'); insert into stu values(2,'女'); 集合类型 set create table stu2( id int, hobby set('java','玩游戏','看书') ); insert into stu2 values(1,'java'); insert into stu2 values(2,'玩游戏'); insert into stu2 values(3,'java,看书'); select * from stu2; 约束 作用：限制每一列能写什么数据，不能写什么数据 类型 主键约束 非空约束 唯一约束 外键约束 检查约束 主键约束: primary key ,保证行的唯一性，要求唯一且非空 -- 列级定义 create table stu( id int primary key, name varchar(30) ); -- 表级定义 create table stu( id int, name varchar(30) primary key(id) ) 注意:表中可以没有主键，但建议在非特殊情况下，都要设置表的主键 一个表中只能有一个主键 一个表中可以使用多个列联合作为主键，称为联合主键，但并不推荐使用 选择没有意义的列比较合适 非空约束：not null，该列不能为空 只能是列级约束，不能是表级约束 唯一约束：unique ，保证列的唯一性 mysql中认为null是不确定值，任何两个null都是不相等的，所以在唯一约束的列上，可以有多个空值 Oracle与MySQL相同，SqlServer唯一约束列只能有一个空 create table user( id int primary key, username varchar(30) unique not null, password varchar(30) not null ); 外键约束：foreign key,保证表数据引用的完整性 constraint 外键名 foreign key (列名) references 引用表名(列名) create table class( id int primary key, name varchar(20) unique not null ); insert into class values(1,'java7'); create table stu( id int, name varchar(30), classId int, primary key(id), foreign key(classId) references class(id) ); insert into stu values(1,'Tom',1); insert into class values(2,'java8'); insert into stu values(2,'Marry',2); select * from stu; 注意:只有主键或唯一键列可以被其他表引用 check约束:对列的值进行限制 create table stu( id int primary key , name varchar(30) not null, age int , check(age >= 18) ); create table test1( id int primary key, startDate date, endDate date, check(startDate &lt;= endDate) ); 约束的位置: 列级约束：把约束写道列的定义处，例如: id int primary key 表级约束：把约束写道列的定义外，例如：id int,primary key(id) 默认值： 当不设置某列值的时候，使用的值 create table stu( id int primary key , name varchar(30) not null, age int default '18', check(age >= 18) ); 自动增长 create table stu( id int auto_increment, name varchar(30) not null, age int default '18', check(age >= 18), primary key(id) ); insert into stu(id,name) values (null,'tom') 只能在非空，主键或唯一键上添加自动增长 一个表中只能有一个自动增长列 查询最后自增长的值： select last_insert_id() 练习： 角色表(role)：id 主键 自增长 ，name 非空 唯一 用户表(user)：id 主键 自增长，username 非空 唯一，密码 默认值：888888 非空，角色编号 外键，年龄 age 不能小于18岁 修改表列的修改-- 添加列 alter table 表名 add 列名 类型 默认值; -- 修改列 alter table 表名 modify 列名 类型 默认值; -- 删除列 alter table 表名 drop 列名; 约束的添加和删除-- 添加约束 alter table 表名 add 约束; -- 删除主键 alter table 表名 drop primary key; -- 删除外键 alter table 表名 drop foreign key 外键名; -- 删除唯一约束 alter table 表名 drop index 唯一索引名(默认为列名) 删除表drop table 表名 重命名表rename table 原表名 to 新表名 复制表-- 复制表结构和数据，但是没有复制约束 create table 表名 as 子查询; -- 复制表结构，包括约束，不复制数据 create table 表名 like 原表名; 窗口函数窗口函数:在每一行上执行一个计算，这个计算涉及到从同一结果集中的其他行获取数据。这个“窗口”是通过定义在一个或多个列上的某种关系来确定的 常用的函数 rank():计算每个窗口内的行的排名 dense_rank():功能与rank类似，但不会跳过排名 row_number():给窗口内的每一行分配一个唯一的数字 案例-- 查询员工姓名,工资及工资排名 select ENAME ,SAL ,rank() over(order by sal desc) `rank` from emp ; -- 查询员工姓名，部门编号，部门内薪水排名 select e.ENAME ,d.DEPTNO , rank() over(partition by d.DEPTNO order by sal desc) `rank`, dense_rank() over(partition by d.DEPTNO order by sal desc) `dense_rank`, row_number() over(partition by d.DEPTNO order by sal desc) `row_number` from emp e join dept d on e.DEPTNO = d.DEPTNO ; limit Top N：limit N 分页: limit starindex,N starindex:从0开始的索引号 -- pageNum 第几页 pageSize:每页最多有多少行 select * from emp order by sal desc limit (pageNum-1)*pageSize,pageSize; 子句执行顺序 from、where、group by、having、select、order by、limit、union 总结 DBMS:软件，一种操作和管理数据库的大型软件 SQL：结构化的查询语言 分类： DQL:SELECT DML:数据的操作语言，insert，delete，update DDL:数据定义语言，create、drop、alter TCL:事务控制语言，commit，rollback，savepoint DCL:数据控制语言，grant，revoke 查询 where：对数据行的筛选 group by：分组 根据group by后列出的列名列表的值相同的分作一组，每组显示一行结果 分组后，select子句中只能出现分组列和分组函数 group by 后列名列表的顺序无关分组 having：对分组后的结果进行筛选 select * from emp having sal > 2000; -- mysql支持，相当于where 但不推荐使用 order by：排序 order by 列名|表达式|列号|列别名 desc降序，asc升序 多列排序：先按照前面的列排序，前面的列值相同的情况下，按照后面的列排序 limit：求topN的问题以及分页 topN:limit N 分页:limit startindex,N 表连接 等值连接和非等值连接 等值连接：表连接中使用等号 非等值连接：表连接中不使用等号 内连接和外连接 内连接：只有匹配的记录会显示出来 外连接：没有匹配的记录也会显示出来 左外连接：left join，左边表中的所有记录至少显示一次 右外连接：right join，右边表中的所有记录至少显示一次 全外连接：full join(MySQL不支持 ，可以使用union连接)，两个表中没有匹配的记录都会至少显示一次 自连接 子查询 非相关子查询：可以独立执行，不依赖于父查询 select * from emp e where sal > (select sal from emp where ename = 'smith') -- 查询各个岗位中最低薪水人的姓名，薪水(多列子查询) select ename,sal from emp e where (sal,job) in (select min(sal),job from emp group by job); 相关子查询：子查询中涉及到了父查询中的某些列，不能独立执行 在select使用: -- 不使用表连接，查询出员工的姓名和部门名称 select ename,(select dname from dept where dept.deptno = e.deptno) from emp e; 在where使用 -- 查询比部门平均工资高的员工编号、姓名、薪水、部门平均薪水 select e.EMPNO ,e.ENAME ,SAL ,(select avg(sal) from emp where e.DEPTNO = emp.DEPTNO) from emp e where e.sal > (select avg(sal) from emp where e.DEPTNO = emp.DEPTNO); 窗口函数 -- 查询员工姓名、工资和其部门平均工资，使用窗口函数不使用分组函数 select ename,sal,DEPTNO ,avg(sal) over(partition by deptno) `平均工资` from emp; DML insert insert into 表名(列名列表) values(对应的值); insert into 表名(列名列表) values(对应的值),(对应的值),(对应的值)...; insert into 表名(列名列表) 子查询; -- 创建一个新的表，结构与emp相同，表中没有数据 create table emp1 like emp; -- 把查询到的部门编号为10的所有员工插入到上述表中 insert into emp1 (select * from emp where deptno = 10); select * from emp1; update update 表名 set 列名 = 列值,列名 = 列值,列名 = 列值... [where 条件] delete delete from 表名 [where 条件] -- 删除高于本岗位平均工资的员工 delete emp from emp join (select job,avg(sal) avgsal from emp e group by job) a on emp.JOB = a.job where emp.SAL > a.avgsal; TCL：事务的控制语言 事务:把一个或多个DML语句组成一个整体，不可分割，要么全部都执行成功，要么全部都执行失败 提交:commit 回滚:rollback 设置保存点:savepoint 保存点名 回滚到保存点:rollback to 保存点名 特性：原子性，一致性，隔离性，持久性 DDL 创建数据库 create database [if not exists] 数据库名; 删除数据库 drop database 数据库名 创建表 create table 表名( 列名 数据类型 约束 默认值 自动增长, 列名 数据类型 约束 默认值 自动增长, 列名 数据类型 约束 默认值 自动增长, ... ); 删除表 drop table 表名 修改表 alter table 表名 add 列名 数据类型 约束 默认值 自动增长, modify 列名 数据类型 约束 默认值 自动增长, drop 列名, add 约束, drop primary key, drop foreign key 外键名, drop index 唯一索引名; 重命名表 rename table 原表名 新表名","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yiyecreb.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Oracle","slug":"Oracle","date":"2023-06-16T16:00:00.000Z","updated":"2023-07-20T08:53:12.762Z","comments":true,"path":"2023/06/17/Oracle/","link":"","permalink":"http://yiyecreb.top/2023/06/17/Oracle/","excerpt":"","text":"Oracle数据库 存储在一起的数据集合 能为多个用户共享 尽可能小的数据冗余 与应用程序彼此独立 数据库管理系统(DBMS) 是一种管理数据库的软件 包括数据库的创建、使用、维护、配置 数据库命令都要通过数据库管理系统处理 关系型数据库 实体以及实体间的各种关系均用关系来表示 用户的角度来看关系就是一张由行和列组成的二维数据表 常见关系型数据库 Oracle 甲骨文 MySQL 甲骨文 SQL Server 微软 DB2 IBM Sybase sybase公司 Oracle数据库简介: 目前是世界上最流行的关系型数据库之一 支持各种操作系统(Windows、Linux、IOS) 数据库领域一直处于领先地位 特点: 可移植性好 使用方便，功能强 适合各种大中小型服务器和微机环境 样例表Dept(部门) deptno:部门编号 dname:部门名称 loc:部门地址 Emp(员工表) empno:员工编号 ename:员工姓名 job:工作岗位 mgr:经历编号 hiredate:入职日期 sal:薪水 comm:奖金 deptno:部门编号 SalGrade(薪水等级表) GRADE:等级编号 LOSAL:最低工资 HISAL:最高工资 结构化的查询语言(SQL) 是操作和检索关系型数据库的标准语言 二十世纪七十年代由IBM公司开发，目前应用于各种关系型数据库 分类: 数据查询语言(DQL):SELECT，从表中查询数据 数据操作语句(DML):INSERT,UPDATE,DELETE,用于添加修改删除数据 事务处理语言(TPL):COMMIT和ROLLBACK，用于提交和回滚事务 数据控制语言(DCL):GRANT和REVOKE,用于授权和收回授权 数据定义语言(DDL):CREATE,DROP,ALTER,用于定义销毁和修改数据库对象 基本SELECT语句 SELECT语句 SELECT子句(SELECT *:查询所有列) FROM子句(FROM DEPT:表示从哪张表查询数据) SQL的相关概念 关键字:SQL语言中的保留字符串 语句:一条完整的SQL语句(独立执行) 子句:部分SQL语句(不能独立执行) 书写规则: 不区分大小写 可以在一行书写也可以多行书写，建议多行书写 关键字不可以分开，缩写或跨行写 选择列 所有列:* SELECT * FROM EMP; 选择指定列:列名之间使用逗号分隔 SELECT ENAME,HIREDATE FROM EMP; 算术运算符 +,-,*,&#x2F;,() 例题: 1.员工转正后，月薪上调20%，请查询出所有员工转正后的月薪。2.员工试用期6个月，转正后月薪上调20%，请查询出所有员工工作第一年的年薪所得（不考虑奖金部分.年薪的试用期6个月的月薪+转正后6个月的月薪) SELECT Ename,SAL,SAL*6+SAL*1.2*6 AS 试用转正年薪,SAL*1.2 AS 转正月薪 FROM EMP; 空值 空值是一种无效的,未赋值的,未知的,不确定的值 空值不同于0或空格或空字符串 包含空值的算术运算后的结果也为空值 列别名 用来在当前查询中重命名列名 书写方式 列名 列别名 列名 AS 列别名 有三种情况需要在列名两侧加上引号 列别名中包含空格 列别名中区分大小写 列别名中包含特殊字符或关键字 NVL(列名,值):空值处理函数,当列名对应的值是空的时候，返回第二个参数，不为空，返回实际值 连接操作符 用于连接列与列、列与字符 形式上为|| SELECT ENAME,JOB,ENAME||'的岗位是'||JOB FROM EMP; 原义字符串 包含在select列表中的一个字符串，一个数字或一个日期 日期和字符串字面量必须使用单引号括起来&#39;&#39;(字面量:直接写到原程序中的固定值) 每个原义字符串会在每一行都出现 SELECT ENAME,JOB,ENAME||'的岗位是'||JOB,'浑南' 公司地址,2000 年终奖金，'20-5月-2023' 日期 FROM EMP; 消除重复行:DISTINCT SELECT DISTINCT JOB FROM EMP; 练习四 1.员工试用期6个月，转正后月薪上调20%，请查询出所有员工工作第一年的所有收入（需考虑奖金部分)， 要求显示格式为:XXX的第一年总收入为XXX。 SELECT ENAME||'第一年总收入为'||((SAL+NVL(COMM,0))*6+(SAL*1.2+NVL(COMM,0))*6) FROM EMP; 2.查询员工表中一共有哪几种岗位类型。 SELECT DISTINCT JOB 岗位类型 FROM EMP; WHERE子句的使用作用 使用WHERE子句限制返回的记录 写在FROM子句后面 语法SELECT 列名列表 FROM 表名 WHERE 条件 比较运算符 &#x3D;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&lt;&gt;（不等于） 比较规则 字符串或日期类型要加上单引号 SELECT * FROM EMP WHERE ENAME = 'SMITH'; SELECT * FROM EMP WHERE HIREDATE > '20-2月-1981'; 字符串内容区分大小写 练习一: 1.查询职位为SALESMAN的员工编号、职位、入职日期。 SELECT EMPNO,JOB,HIREDATE FROM EMP WHERE JOB = 'SALESMAN'; 2.查询1985年12月31日之前入职的员工姓名及入职日期。 SELECT ENAME,HIREDATE FROM EMP WHERE HIREDATE &lt; '31-12月-1985'; 3.查询部门编号不在10部门的员工姓名、部门编号。 SELECT ENAME,DEPTNO FROM EMP WHERE DEPTNO &lt;> 10; 特殊比较运算符 between … and … 在XXX到XXX之间 SELECT * FROM EMP WHERE EMPNO BETWEEN 7800 AND 9999; IN(列表,列表) 或者 SELECT * FROM EMP WHERE DEPTNO IN(20,30); LIKE 模糊查询 &#x2F;* 使用通配符代替未知的信息 通配符:%表示任意多个字符 _表示任意一个字符 使用ESCAPE进行转义 SELECT * FROM EMP WHERE ENAME LIKE &#39;%@_%&#39; ESCAPE &#39;@&#39;; *&#x2F; SELECT * FROM EMP WHERE ENAME LIKE &#39;__O%&#39;; 练习2: 1.查询入职日期在82年至85年的员工姓名，入职日期。 SELECT ENAME,HIREDATE FROM EMP WHERE HIREDATE BETWEEN &#39;1-1月-1982&#39; AND &#39;31-12月-1985&#39;; 2.查询月薪在3000到5000的员工姓名，月薪。 SELECT ENAME,SAL FROM EMP WHERE SAL BETWEEN 3000 AND 5000; 3.查询部门编号为10或者20的员工姓名，部门编号。 SELECT ENAME,DEPTNO FROM EMP WHERE DEPTNO IN(10,20); 4.查询经理编号为7902，7566，7788的员工姓名，经理编号。 SELECT ENAME,MGR FROM EMP WHERE MGR IN(7902,7566,7788); IS NULL 判断空值 练习三: 1.查询员工姓名以W开头的员工姓名。 SELECT ENAME FROM EMP WHERE ENAME LIKE &#39;W%&#39;; 2.查询员工姓名倒数第2个字符为T的员工姓名。 SELECT ENAME FROM EMP WHERE ENAME LIKE &#39;%T_&#39;; 3.查询奖金为空的员工姓名，奖金。 SELECT ENAME,COMM FROM EMP WHERE COMM IS NULL; 逻辑运算符 AND(与):两个条件同时满足就为TRUE; OR(或):两个条件有一个满足就为TRUE; NOT(非):对指定条件取相反 练习四: 1.查询工资超过2000并且职位是MANAGER,或者职位是SALESMAN的员工姓名、职位、工资 SELECT ENAME,JOB,SAL FROM EMP WHERE SAL > 2000 AND JOB = 'MANAGER' OR JOB = 'SALESMAN' ; 2.查询工资超过2000并且职位是 MANAGER或SALESMAN的员工姓名、职位、工资。 SELECT ENAME,JOB,SAL FROM EMP WHERE (JOB = 'MANAGER' OR JOB = 'SALESMAN') AND SAL > 2000 ; 3.查询部门在10或者20，并且工资在3000到5000之间的员工姓名、部门、工资。 SELECT ENAME,DEPTNO,SAL FROM EMP WHERE DEPTNO IN(10,20) AND SAL BETWEEN 3000 AND 5000; 4.查询入职日期在81年，并且职位不是SALES开头的员工姓名、入职日期、职位。 SELECT ENAME,HIREDATE,JOB FROM EMP WHERE HIREDATE BETWEEN '1-1月-1981' AND '31-12月-1981' AND JOB NOT LIKE 'SALES%'; 5.查询职位为SALESMAN或MANAGER，部门编号为10或者20，姓名包含A的员工姓名、职位、部门编号。 SELECT ENAME,JOB,DEPTNO FROM EMP WHERE (JOB = 'MANAGER' OR JOB = 'SALESMAN') AND DEPTNO IN(10,20) AND ENAME LIKE '%A%'; 排序 作用:用来排序 语法: ORDER BY{列名|表达式|别名|列号} ASC:默认值，升序 DESC:降序 注意:空值最大(MySQL则相反) 可多列排序，先按照前面的列排序，如果前面的列值相同，使用后面的列进行排序 特殊情况: ORDER BY子句可以出现SELECT子句中没有列出的列 子句的执行顺序:FROM WHERE SELECT ORDER 表连接 为什么需要表连接 需要查询的数据分布在多张表中 什么是表连接 连接是在多张表之间通过一定的条件，使得表之间发生关联，进而能从多张表中获取数据 连接的类型 按连接条件分:等值连接，不等值连接 按其他的连接方法分:外连接和内连接 多表连接的写法： Oracle风格或旧式连接 ANSI 99(标准语法) 笛卡尔积:第一张表的所有行和第二张表的所有行都发生连接 SELECT * FROM EMP,DEPT; 等值连接 用等号连接关联的列 SELECT * FROM EMP,DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO; SELECT EMP.*,DEPT.DNAME,DEPT.LOC FROM EMP,DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO; 表连接注意 未明确定义的列:两张表中都存在的名称相同的列，解决方法:在列名前加上表名作为前缀 通常在表连接的时候，会给表起别名，目的是书写方便，一旦起了别名，在当前查询中，不能再使用原来的表名，一律使用表别名替代 非等值连接:不使用等号对表进行连接 SELECT * FROM SALGRADE S,EMP E WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL; 内连接:只有匹配的记录才会显示到最终的结果集中 SELECT * FROM EMP,DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO; SELECT 列名 FROM 表1 INNER JOIN 表2 ON 表1.列名 = 表2.列名 -- 注意:INNER可以省略 外连接:两个表连接没有匹配的记录也会显示出来，+号写在where条件中需要添加空白行的一段 主表:该表中的所有数据至少出现一次 从表:只有匹配上的记录才显示(+号写在从表一端) SELECT ENAME,EMPNO,D.DEPTNO,D.DNAME,D.LOC FROM EMP E,DEPT D WHERE E.DEPTNO(+) = D.DEPTNO; -- 左外连接 SELECT 列名 FROM 表1 LEFT OUTER JOIN 表2 ON 表1.列名 = 表2.列名; -- OUTER可以省略 -- 或者 SELECT 列名 FROM 表1,表2 WHERE 表1.列名 = 表2.列名(+); Oracle风格，表连接特点 表连接的条件和行筛选条件都写到where子句中 多于两张表的连接 SELECT ENAME,LOC,GRADE FROM EMP E,DEPT D,SALGRADE S WHERE E.DEPTNO &#x3D; D.DEPTNO AND E.SAL BETWEEN S.LOSAL AND S.HISAL; 先将两张表连接起来，再基于已经生成的连接结果(临时表)，再与第三张表连接 自连接 是一个表通过某种条件和自身进行连接的一种方式，就如同两个表连接一样 SELECT ENAME,LOC,GRADE FROM EMP E,DEPT D,SALGRADE S WHERE E.DEPTNO = D.DEPTNO AND E.SAL BETWEEN S.LOSAL AND S.HISAL; 分组函数 MAX函数:取最大值 MIN函数:取最小值 SUM函数:求和 AVG函数:求平均数 COUNT函数:查询总的记录数(空值不算):COUNT(*)指行数 DISTINCT函数:去重 GROUP BY子句 SELECT 列名 FROM 表名 WHERE 条件 GROUP BY 分组列 ORDER BY 列名; -- 多值的列和分组函数不能混用 -- GROUP BY A,B 没有先后之分，按AB相同分组 -- 分组的条件不能写在WHERE后面 -- 执行顺序:FROM WHERE GROUP SELECT ORDER -- 分组函数AVG是在GROUP期间完成的一个语句，WHERE执行分组函数时还未计算出结果 -- 解决方法如下的HAVING语句 -- 一旦分组，SELECT后只能写分组条件和分组函数(但MySQL与之不同) HAVING子句:负责分组条件的筛选 -- 标准书写顺序 SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... -- 标准执行顺序 FROM ... WHERE ... GROUP BY ... HAVING ... SELECT ... ORDER BY ... -- 注意:MYSQL中的执行顺序 FROM ... WHERE ... GROUP BY ... SELECT ... HAVING ... ORDER BY ... 子查询 括号中的查询称为子查询，外面的查询为父查询，子查询可以独立执行，先执行子查询得到确定的结果，父查询基于这些结果再执行 使用注意: 子查询用括号括起来 放在比较运算符的右边 大多数情况下，子查询不需要排序 子查询分类: 单行子查询:子查询中返回单行单列，使用的比较运算符:&gt;=、&lt;=、&gt;、&lt;、&lt;&gt;、= -- 查询比该部门平均薪水低的员工信息 SELECT * FROM EMP E JOIN (SELECT DEPTNO,AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO ) A ON E.DEPTNO &#x3D; A.DEPTNO WHERE E.SAL &lt; A.AVGSAL; 多行子查询:子查询中返回多行单列，使用的比较运算符:IN、ANY、ALL IN:和以前介绍的功能一致，判断是否与子查询的任意一个返回值相同。 -- 查询是经理的员工姓名，工资。 SELECT ENAME,SAL FROM EMP WHERE EMPNO IN( SELECT MGR FROM EMP ); ANY:表示和子查询的任意一行结果进行比较，有一个满足条件即可。 -- 查询是经理的员工姓名，工资。(ANY) SELECT ENAME,SAL FROM EMP WHERE EMPNO &#x3D; ANY( SELECT MGR FROM EMP ); -- 查询部门编号不为10，且工资比10部门任意一名工资高的员工编号，姓名，职位，工资。 SELECT EMPNO,ENAME,JOB,SAL FROM EMP WHERE DEPTNO &lt;&gt; 10 AND SAL &gt; ANY( SELECT SAL FROM EMP WHERE DEPTNO &#x3D; 10 ); ALL:表示和子查询的所有行结果进行比较，每一行必须都满足条件。 -- 查询部门编号不为10，且工资比10部门所有员工工资高的员工编号，姓名，职位，工资。 SELECT EMPNO,ENAME,JOB,SAL FROM EMP WHERE DEPTNO &lt;&gt; 10 AND SAL &gt; ALL( SELECT SAL FROM EMP WHERE DEPTNO &#x3D; 10 ); 多列子查询:子查询中返回多行多列 -- 查询各个部门收入最低的人的姓名 SELECT ENAME FROM EMP WHERE (SAL,DEPTNO) IN (SELECT MIN(SAL),DEPTNO FROM EMP GROUP BY DEPTNO); -- 1.查询职位及经理和10部门任意一个员工职位及经理相同的员工姓名，职位，不包括10部门员工 SELECT ENAME,JOB FROM EMP WHERE(JOB,MGR) IN (SELECT JOB,MGR FROM EMP WHERE DEPTNO &#x3D; 10) AND DEPTNO &lt;&gt; 10; -- 2.查询职位及经理和10部门任意一个员工职位或经理相同的员工姓名，职位，不包括10部门员工 SELECT ENAME,JOB FROM EMP WHERE (JOB IN (SELECT JOB FROM EMP WHERE DEPTNO &#x3D; 10) OR MGR IN (SELECT MGR FROM EMP WHERE DEPTNO &#x3D; 10)) AND DEPTNO &lt;&gt; 10; 注意:如果子查询中有空值，就不能使用NOT IN运算符 ROWNUM ROWNUM是一个伪列，伪列是使用上类似于表中的列而实际没有存储在表中的特殊对象 ROWNUM的功能是在每次查询时返回结果集的顺序数，这个顺序数是在记录输出时才一步一步产生的，第一行显示1，第二行显示2，以此类推 ROWNUM只能进行小于和小于等于的运算，不能执行大于或大于等于运算 TOP-N 是实现表中按照某个列排序输出最大或最小的N条记录 SELECT ROWNUM,A.ENAME FROM (SELECT ENAME FROM EMP ORDER BY SAL DESC) A WHERE ROWNUM &lt; 3; 分页 pagesize 每页的记录数(每页最多有多少行) pagenum 目标页数(第几页) -- 1.按照每页显示5条记录，分别查询工资最高的第1页，第2页，第3页信息，要求显示员工姓名、入职日期、部门名称、工资。 SELECT B.ENAME 姓名, B.HIREDATE 入职日期, DNAME 部门名称, B.SAL 工资 FROM (SELECT A.*, ROWNUM NM FROM (SELECT * FROM EMP ORDER BY SAL DESC) A WHERE ROWNUM &lt;&#x3D; 5) B JOIN DEPT D ON B.DEPTNO &#x3D; D.DEPTNO WHERE NM &gt;&#x3D; 1; SELECT B.ENAME 姓名, B.HIREDATE 入职日期, DNAME 部门名称, B.SAL 工资 FROM (SELECT A.*, ROWNUM NM FROM (SELECT * FROM EMP ORDER BY SAL DESC) A WHERE ROWNUM &lt;&#x3D; 10) B JOIN DEPT D ON B.DEPTNO &#x3D; D.DEPTNO WHERE NM &gt;&#x3D; 6; SELECT B.ENAME 姓名, B.HIREDATE 入职日期, DNAME 部门名称, B.SAL 工资 FROM (SELECT A.*, ROWNUM NM FROM (SELECT * FROM EMP ORDER BY SAL DESC) A WHERE ROWNUM &lt;&#x3D; 15) B JOIN DEPT D ON B.DEPTNO &#x3D; D.DEPTNO WHERE NM &gt;&#x3D; 11; 相关子查询 当子查询中引用的父查询表中的一个列时,Oracle服务器执行相关子查询 执行过程: 取得父查询的候选行 用候选行被子查询引用列的值执行子查询 用来自子查询的值确认或取消候选行 重复上面三步直到父查询中没有剩余的候选行为止 相关子查询不可以独立执行 -- 查询工资高于部门平均薪水的员工信息 SELECT * FROM EMP E WHERE SAL &gt; (SELECT AVG(SAL) FROM EMP WHERE DEPTNO &#x3D; E.DEPTNO); EXISTS:判断是否存在,操作过程: 子查询如果有记录找到，子查询语句不会继续执行，返回值为true 子查询中如果到表的末尾也没找到，返回false -- 查询是经理的员工姓名 SELECT ENAME FROM EMP E WHERE EXISTS(SELECT (&#39;1&#39;) FROM EMP WHERE E.EMPNO &#x3D; MGR ); NOT EXISTS:与上面相反，判断子查询是否没有返回值，如果没有返回值，表达式为true，如果找到一条返回值，则为false -- 查询不是经理的员工姓名 SELECT ENAME FROM EMP E WHERE NOT EXISTS(SELECT (&#39;1&#39;) FROM EMP WHERE E.EMPNO &#x3D; MGR );","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yiyecreb.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"2023年两天一夜的大连旅游记录","slug":"0613大连旅游记录","date":"2023-06-13T14:48:42.889Z","updated":"2023-07-20T08:53:03.862Z","comments":true,"path":"2023/06/13/0613大连旅游记录/","link":"","permalink":"http://yiyecreb.top/2023/06/13/0613%E5%A4%A7%E8%BF%9E%E6%97%85%E6%B8%B8%E8%AE%B0%E5%BD%95/","excerpt":"","text":"2023年6月12日:老虎滩海洋主题公园浏览","categories":[{"name":"日常","slug":"日常","permalink":"http://yiyecreb.top/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常分享","slug":"日常分享","permalink":"http://yiyecreb.top/tags/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB/"}]},{"title":"若依管理系统学习使用经验(佛系更新中)","slug":"若依管理系统开发学习经验","date":"2023-06-03T06:46:33.592Z","updated":"2023-07-20T08:53:29.319Z","comments":true,"path":"2023/06/03/若依管理系统开发学习经验/","link":"","permalink":"http://yiyecreb.top/2023/06/03/%E8%8B%A5%E4%BE%9D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/","excerpt":"","text":"话说在前 本文章仅用来共享我个人使用时遇见的问题以及自己在使用中学会的一些使用方式 什么是若依:若依是一套全部开源的快速开发平台(可以参考人人开源)，便于实现各种管理系统的快速开发 环境配置 MySQL &gt;&#x3D; 5.7 JDK &gt;&#x3D; 1.8 Maven &gt;&#x3D; 3.0 Redis(我个人使用的是5.0.14.1) NodeJS 运行软件:IDEA(当然eclipse也是可以的) 若依官网:ruoyi.vip 若依Gitee源码仓库:RuoYi-Vue: 🎉 基于SpringBoot，Spring Security，JWT，Vue &amp; Element 的前后端分离权限管理系统，同时提供了 Vue3 的版本 (gitee.com) 运行将从gitee上下载好的若依项目使用IDEA或eclipse打开，等待maven根据pom文件下载框架依赖以及jar包 连接数据库:建立一个名为ry的数据库(当然,起别的名字也可以,但要注意在配置文件内改变默认的数据库名称),在数据库内运行文件内自带的两个sql文件 修改数据库连接:编辑resources目录下的application-druid.yml url为数据库地址,username为数据库账号,password为数据库密码 修改服务器配置编辑resources目录下的application.yml port为端口号 在运行软件内开始运行显示: (♥◠‿◠)ﾉﾞ 若依启动成功 ლ(´ڡ&#96;ლ)ﾞ .-------. ____ __ | _ _ \\ \\ \\ &#x2F; &#x2F; | ( &#39; ) | \\ _. &#x2F; &#39; |(_ o _) &#x2F; _( )_ .&#39; | (_,_).&#39; __ ___(_ o _)&#39; | |\\ \\ | || |(_,_)&#39; | | \\ &#96;&#39; &#x2F;| &#96;-&#39; &#x2F; | | \\ &#x2F; \\ &#x2F; &#39;&#39;-&#39; &#96;&#39;-&#39; &#96;-..-&#39; 即为运行成功 无法启动的一些常见原因:1.Redis未启动或Redis本身设有密码(启动redis或者把密码配置好就行) 2.数据库未连接 前端运行找到ruoyi-ui文件夹,在ruoyi-ui内打开控制台,输入npm install下载依赖,再输入npm run dev运行前端VUE项目(PS:端口号在vue-config.js文件内修改) 运行成功后在浏览器内输入localhost:80(默认端口),即可进入登录页面 关于验证码的问题；如果登录界面没有验证码图片内容，说明后端端口没连接上或后端没运行,将后端代码运行或连接端口就可以解决(所以说没事别乱改默认端口,后面有苦给你吃哦) 更新内容至此，下次更新随缘","categories":[{"name":"学习经验","slug":"学习经验","permalink":"http://yiyecreb.top/categories/%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"五月二十八号的散步心得","slug":"0528","date":"2023-05-28T13:57:26.898Z","updated":"2023-07-20T08:53:43.333Z","comments":true,"path":"2023/05/28/0528/","link":"","permalink":"http://yiyecreb.top/2023/05/28/0528/","excerpt":"","text":"近些天因为大大小小的各种事情加生活琐碎还有夏天的闷热真的导致心情很难蚌，多少有点控制不了自己的情绪，和女朋友一起在学校里散步真的解决了很多问题，至少有了缓解的依靠，真的蛮幸运的(话说以后这博客不会大部分都是我的碎碎念和日常吧[划去])","categories":[{"name":"日常","slug":"日常","permalink":"http://yiyecreb.top/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常分享","slug":"日常分享","permalink":"http://yiyecreb.top/tags/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB/"}]},{"title":"欢迎来到依夜的个人博客","slug":"我的第一个笔记","date":"2023-05-24T05:25:42.972Z","updated":"2023-07-20T08:53:16.496Z","comments":true,"path":"2023/05/24/我的第一个笔记/","link":"","permalink":"http://yiyecreb.top/2023/05/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AC%94%E8%AE%B0/","excerpt":"","text":"欢迎来到依夜的博客 从2023年5月27日起本博客正式开始投入，我的博客一般会发一些我的学习笔记，生活趣事分享以及一些观影观番游戏体验感谢，也愿意与更多的网络朋友们建议友情链接交流技术和爱好","categories":[{"name":"日常","slug":"日常","permalink":"http://yiyecreb.top/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常分享","slug":"日常分享","permalink":"http://yiyecreb.top/tags/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://yiyecreb.top/categories/Java/"},{"name":"算法","slug":"算法","permalink":"http://yiyecreb.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"DOS","slug":"DOS","permalink":"http://yiyecreb.top/categories/DOS/"},{"name":"数据库","slug":"数据库","permalink":"http://yiyecreb.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"日常","slug":"日常","permalink":"http://yiyecreb.top/categories/%E6%97%A5%E5%B8%B8/"},{"name":"学习经验","slug":"学习经验","permalink":"http://yiyecreb.top/categories/%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yiyecreb.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"日常分享","slug":"日常分享","permalink":"http://yiyecreb.top/tags/%E6%97%A5%E5%B8%B8%E5%88%86%E4%BA%AB/"}]}